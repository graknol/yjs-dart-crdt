// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class IdSetEncoderV1 {
  constructor()   constructor () {
    this.restEncoder = encoding.createEncoder()
  }


  dynamic toUint8Array()   toUint8Array () {
    return encoding.toUint8Array(this.restEncoder)
  }


  void resetIdSetCurVal()   resetIdSetCurVal () {
    // nop
  }


  void writeIdSetClock(dynamic clock)   writeIdSetClock (clock) {
    encoding.writeVarUint(this.restEncoder, clock)
  }


  void writeIdSetLen(dynamic len)   writeIdSetLen (len) {
    encoding.writeVarUint(this.restEncoder, len)
  }


}


class UpdateEncoderV1 extends IdSetEncoderV1 {
  void writeLeftID(String id)   writeLeftID (id) {
    encoding.writeVarUint(this.restEncoder, id.client)
    encoding.writeVarUint(this.restEncoder, id.clock)
  }


  void writeRightID(String id)   writeRightID (id) {
    encoding.writeVarUint(this.restEncoder, id.client)
    encoding.writeVarUint(this.restEncoder, id.clock)
  }


  void writeClient(dynamic client)   writeClient (client) {
    encoding.writeVarUint(this.restEncoder, client)
  }


  void writeInfo(dynamic info)   writeInfo (info) {
    encoding.writeUint8(this.restEncoder, info)
  }


  void writeString(dynamic s)   writeString (s) {
    encoding.writeVarString(this.restEncoder, s)
  }


  void writeParentInfo(String isYKey)   writeParentInfo (isYKey) {
    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0)
  }


  void writeTypeRef(dynamic info)   writeTypeRef (info) {
    encoding.writeVarUint(this.restEncoder, info)
  }


  void writeLen(dynamic len)   writeLen (len) {
    encoding.writeVarUint(this.restEncoder, len)
  }


  void writeAny(dynamic any)   writeAny (any) {
    encoding.writeAny(this.restEncoder, any)
  }


  void writeBuf(dynamic buf)   writeBuf (buf) {
    encoding.writeVarUint8Array(this.restEncoder, buf)
  }


  void writeJSON(dynamic embed) // PLACEHOLDER: Add import 'dart:convert';
  writeJSON (embed) {
    encoding.writeVarString(this.restEncoder, jsonEncode(embed))
  }


  void writeKey(String key)   writeKey (key) {
    encoding.writeVarString(this.restEncoder, key)
  }


}


class IdSetEncoderV2 {
  constructor()   constructor () {
    this.restEncoder = encoding.createEncoder() // encodes all the rest / non-optimized
    this.dsCurrVal = 0
  }


  dynamic toUint8Array()   toUint8Array () {
    return encoding.toUint8Array(this.restEncoder)
  }


  void resetIdSetCurVal()   resetIdSetCurVal () {
    this.dsCurrVal = 0
  }


  void writeIdSetClock(dynamic clock)   writeIdSetClock (clock) {
    const diff = clock - this.dsCurrVal
    this.dsCurrVal = clock
    encoding.writeVarUint(this.restEncoder, diff)
  }


  void writeIdSetLen(dynamic len)   writeIdSetLen (len) {
    if (len == 0) {
      error.unexpectedCase()
    }
    encoding.writeVarUint(this.restEncoder, len - 1)
    this.dsCurrVal += len
  }


}


const dynamic diff = clock - this.dsCurrVal;

class UpdateEncoderV2 extends IdSetEncoderV2 {
  constructor()   constructor () {
    super()
    /**
     * @type {Map<string,number>}
     */
    this.keyMap = <String, dynamic>{}
    /**
     * Refers to the next unique key-identifier to me used.
     * See writeKey method for more information.
     *
     * @type {number}
     */
    this.keyClock = 0
    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder()
    this.clientEncoder = new encoding.UintOptRleEncoder()
    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder()
    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder()
    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8)
    this.stringEncoder = new encoding.StringEncoder()
    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8)
    this.typeRefEncoder = new encoding.UintOptRleEncoder()
    this.lenEncoder = new encoding.UintOptRleEncoder()
  }


  dynamic toUint8Array()   toUint8Array () {
    const encoder = encoding.createEncoder()
    encoding.writeVarUint(encoder, 0) // this is a feature flag that we might use in the future
    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder))
    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder))
    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array())
    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array())
    // @note The rest encoder is appended! (note the missing var)
    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder))
    return encoding.toUint8Array(encoder)
  }


  void writeLeftID(String id)   writeLeftID (id) {
    this.clientEncoder.write(id.client)
    this.leftClockEncoder.write(id.clock)
  }


  void writeRightID(String id)   writeRightID (id) {
    this.clientEncoder.write(id.client)
    this.rightClockEncoder.write(id.clock)
  }


  void writeClient(dynamic client)   writeClient (client) {
    this.clientEncoder.write(client)
  }


  void writeInfo(dynamic info)   writeInfo (info) {
    this.infoEncoder.write(info)
  }


  void writeString(dynamic s)   writeString (s) {
    this.stringEncoder.write(s)
  }


  void writeParentInfo(String isYKey)   writeParentInfo (isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0)
  }


  void writeTypeRef(dynamic info)   writeTypeRef (info) {
    this.typeRefEncoder.write(info)
  }


  void writeLen(dynamic len)   writeLen (len) {
    this.lenEncoder.write(len)
  }


  void writeAny(dynamic any)   writeAny (any) {
    encoding.writeAny(this.restEncoder, any)
  }


  void writeBuf(dynamic buf)   writeBuf (buf) {
    encoding.writeVarUint8Array(this.restEncoder, buf)
  }


  void writeJSON(dynamic embed)   writeJSON (embed) {
    encoding.writeAny(this.restEncoder, embed)
  }


  void writeKey(String key)   writeKey (key) {
    const clock = this.keyMap[key]
    if (clock == undefined) {
      /**
       * @todo uncomment to introduce this feature finally
       *
       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
       * Furthermore, I forgot to set the keyclock. So everything was working fine.
       *
       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
       *
       * I don't know yet how to reintroduce this feature..
       *
       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
       *
       */
      // this.keyMap[key] = this.keyClock
      this.keyClockEncoder.write(this.keyClock++)
      this.stringEncoder.write(key)
    } else {
      this.keyClockEncoder.write(clock)
    }
  }


}


const dynamic encoder = encoding.createEncoder();

const dynamic clock = this.keyMap.get(key);

