// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class InsertStringOp {
  constructor(dynamic insert, dynamic attributes, dynamic attribution)   constructor (insert, attributes, attribution) {
    this.insert = insert
    this.attributes = attributes
    this.attribution = attribution
  }


  String type()   get type () {
    return 'insert'
  }


  dynamic length()   get length () {
    return (this.insert.constructor == Array || this.insert.constructor == String) ? this.insert.length : 1
  }


  dynamic toJSON()   toJSON () {
    return object.assign({ insert: this.insert }, this.attributes ? { attributes: this.attributes } : ({}), this.attribution ? { attribution: this.attribution } : ({}))
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.insert, other.insert) && fun.equalityDeep(this.attributes, other.attributes) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class InsertArrayOp {
  constructor(dynamic insert, dynamic attributes, dynamic attribution)   constructor (insert, attributes, attribution) {
    this.insert = insert
    this.attributes = attributes
    this.attribution = attribution
  }


  String type()   get type () {
    return 'insert'
  }


  dynamic length()   get length () {
    return this.insert.length
  }


  dynamic toJSON()   toJSON () {
    return object.assign({ insert: this.insert }, this.attributes ? { attributes: this.attributes } : ({}), this.attribution ? { attribution: this.attribution } : ({}))
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.insert, other.insert) && fun.equalityDeep(this.attributes, other.attributes) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class InsertEmbedOp {
  constructor(dynamic insert, dynamic attributes, dynamic attribution)   constructor (insert, attributes, attribution) {
    this.insert = insert
    this.attributes = attributes
    this.attribution = attribution
  }


  String type()   get type () {
    return 'insertEmbed'
  }


  dynamic length()   get length () {
    return 1
  }


  dynamic toJSON()   toJSON () {
    return object.assign({ insert: this.insert }, this.attributes ? { attributes: this.attributes } : ({}), this.attribution ? { attribution: this.attribution } : ({}))
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.insert, other.insert) && fun.equalityDeep(this.attributes, other.attributes) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class DeleteOp {
  constructor(dynamic len)   constructor (len) {
    this.delete = len
  }


  String type()   get type () {
    return 'delete'
  }


  dynamic length()   get length () {
    return 0
  }


  dynamic toJSON()   toJSON () {
    return { delete: this.delete }
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.delete == other.delete
  }


}


class RetainOp {
  constructor(dynamic retain, dynamic attributes, dynamic attribution)   constructor (retain, attributes, attribution) {
    this.retain = retain
    this.attributes = attributes
    this.attribution = attribution
  }


  String type()   get type () {
    return 'retain'
  }


  dynamic length()   get length () {
    return this.retain
  }


  dynamic toJSON()   toJSON () {
    return object.assign({ retain: this.retain }, this.attributes ? { attributes: this.attributes } : {}, this.attribution ? { attribution: this.attribution } : {})
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.retain == other.retain && fun.equalityDeep(this.attributes, other.attributes) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class ModifyOp {
  constructor(dynamic delta)   constructor (delta) {
    this.modify = delta
  }


  String type()   get type () {
    return 'modify'
  }


  dynamic length()   get length () {
    return 1
  }


  dynamic toJSON()   toJSON () {
    return { modify: this.modify.toJSON() }
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.modify[traits.EqualityTraitSymbol](other.modify)
  }


}


class AbstractDelta {
  constructor()   constructor () {
    this.remote = false
    /**
     * @type {any} origin
     */
    this.origin = null
    this.isDiff = true
  }


  void ()   [traits.EqualityTraitSymbol] (_other) {
    error.methodUnimplemented()
  }


}


class AbstractArrayDelta extends AbstractDelta {
  dynamic *     (insertOp, index) = > insertOp.insert,;
  dynamic *     (retainOp, index) = > insertOp.retain;
  dynamic *     (deleteOp, index) = > insertOp.delete;

  constructor(dynamic type)   constructor (type) {
    super()
    this.type = type
    /**
     * @type {Array<TDeltaOp>}
     */
    this.ops = []
  }


  void ()    * @template {(d:TDeltaOp) => DeltaOp<any,any,any>} Mapper


  dynamic extends(dynamic d:TDeltaOp)    * @return {AbstractArrayDeltaBuilder<Type, Mapper extends (d:TDeltaOp) => infer OP ? OP : unknown,Modifiers>}


  dynamic map(dynamic f)   map (f) {
    const d = /** @type {AbstractArrayDeltaBuilder<Type,any,Modifiers>} */ (new /** @type {any} */ (this.constructor)(this.type))
    d.ops = this.ops.map(f)
    // @ts-ignore
    d.lastOp = d.ops[d.ops.length - 1] ?? null
    return d
  }


  void forEach(dynamic (op, int index)    *   d.forEach((op, index) => {
   *     if (op instanceof delta.InsertArrayOp) {
   *       op.insert
   *     } else if (op instanceof delta.RetainOp ) {
   *       op.retain
   *     } else if (op instanceof delta.DeleteOp) {
   *       op.delete
   *     }
   *   })


  void ()    * @param {null|((d:TDeltaOp,index:number)=>void)} f


  void ()    * @param {null|((insertOp:Exclude<TDeltaOp,RetainOp|DeleteOp|ModifyOp<any>>,index:number)=>void)} insertHandler


  void ()    * @param {null|((retainOp:RetainOp,index:number)=>void)} retainHandler


  void ()    * @param {null|((deleteOp:DeleteOp,index:number)=>void)} deleteHandler


  void ()    * @param {null|(Modifiers extends undefined ? null : ((modifyOp:ModifyOp<Modifiers extends undefined ? never : Modifiers>,index:number)=>void))} modifyHandler


  void forEach(dynamic f = null, dynamic insertHandler = null, dynamic retainHandler = null, dynamic deleteHandler = null, dynamic modifyHandler = null)   forEach (f = null, insertHandler = null, retainHandler = null, deleteHandler = null, modifyHandler = null) {
    for (
      let i = 0, index = 0, op = this.ops[i];
      i < this.ops.length;
      i++, index += op.length, op = this.ops[i]
    ) {
      f?.(op, index)
      switch (op.constructor) {
        case RetainOp:
          retainHandler?.(/** @type {RetainOp} */ (op), index)
          break
        case DeleteOp:
          deleteHandler?.(/** @type {DeleteOp} */ (op), index)
          break
        case ModifyOp:
          modifyHandler?.(/** @type {any}) */ (op), index)
          break
        default:
          insertHandler?.(/** @type {any} */ (op), index)
      }
    }
  }


  dynamic equals(dynamic other)   equals (other) {
    return this[traits.EqualityTraitSymbol](other)
  }


  dynamic toJSON()   toJSON () {
    return this.ops.map(o => o.toJSON())
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.ops, other.ops)
  }


}


const dynamic d = /** @type {AbstractArrayDeltaBuilder<Type,any,Modifiers>} */ (new /** @type {any} */ (this.constructor)(this.type));

dynamic i = 0, index = 0, op = this.ops[i];

class MapInsertOp {
  constructor(dynamic value, dynamic prevValue, dynamic attribution)   constructor (value, prevValue, attribution) {
    this.prevValue = prevValue
    this.attribution = attribution
    this.value = value
  }


  String type()   get type () { return 'insert' }


  dynamic toJSON()   toJSON () {
    return {
      type: this.type,
      value: this.value,
      prevValue: this.prevValue,
      attribution: this.attribution
    }
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.value, other.value) && fun.equalityDeep(this.prevValue, other.prevValue) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class MapDeleteOp {
  constructor(dynamic prevValue, dynamic attribution)   constructor (prevValue, attribution) {
    this.prevValue = prevValue
    this.attribution = attribution
  }


  dynamic value()   get value () { return undefined }


  String type()   get type () { return 'delete' }


  dynamic toJSON()   toJSON () {
    return {
      type: this.type,
      prevValue: this.prevValue,
      attribution: this.attribution
    }
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.prevValue, other.prevValue) && fun.equalityDeep(this.attribution, other.attribution)
  }


}


class MapModifyOp {
  constructor(dynamic delta)   constructor (delta) {
    this.modify = delta
  }


  dynamic value()   get value () { return undefined }


  String type()   get type () { return 'modify' }


  dynamic toJSON()   toJSON () {
    return {
      type: this.type,
      modify: this.modify.toJSON()
    }
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.modify[traits.EqualityTraitSymbol](other.modify)
  }


}


class MapDelta extends AbstractDelta {
  dynamic *     (insertOp, index) = > insertOp.insert,;
  dynamic *     (retainOp, index) = > insertOp.retain;
  dynamic *     (deleteOp, index) = > insertOp.delete;
  dynamic *     (modifyOp, index) = > insertOp.modify;

  constructor()   constructor () {
    super()
    /**
     * @type {Map<keyof Vals,MapDeltaChange<Vals[keyof Vals],Modifiers>>}
     */
    this.changes = map.create()
    /**
     * @type {Attribution_?}
     */
    this.usedAttribution = null
  }


  void forEach(dynamic (op, int index)    *   d.forEach((op, index) => {
   *     if (op instanceof delta.InsertArrayOp) {
   *       op.insert
   *     } else if (op instanceof delta.RetainOp ) {
   *       op.retain
   *     } else if (op instanceof delta.DeleteOp) {
   *       op.delete
   *     } else if (op instanceof delta.ModifyOp) {
   *       op.modify
   *     }
   *   })


  void ()    * @param {null|((change:MapDeltaChange<Vals[keyof Vals],Modifiers>,key:keyof Vals)=>void)} changeHandler


  void ()    * @param {null|((insertOp:MapInsertOp<Vals[keyof Vals]>,key:keyof Vals)=>void)} insertHandler


  void ()    * @param {null|((deleteOp:MapDeleteOp<Vals[keyof Vals]>,key:keyof Vals)=>void)} deleteHandler


  void ()    * @param {null|((modifyOp:(MapModifyOp<Modifiers extends undefined ? never : Modifiers>),key:keyof Vals)=>void)} modifyHandler


  void forEach(dynamic changeHandler = null, dynamic insertHandler = null, dynamic deleteHandler = null, dynamic modifyHandler = null)   forEach (changeHandler = null, insertHandler = null, deleteHandler = null, modifyHandler = null) {
    this.changes.forEach((change, key) => {
      changeHandler?.(change, key)
      switch (change.constructor) {
        case MapDeleteOp:
          deleteHandler?.(/** @type {MapDeleteOp<Vals[keyof Vals]>} */ (change), key)
          break
        case MapInsertOp:
          insertHandler?.(/** @type {MapInsertOp<Vals[keyof Vals]>} */ (change), key)
          break
        case MapModifyOp:
          modifyHandler?.(/** @type {MapModifyOp<Modifiers extends undefined ? never : Modifiers>} */ (change), key)
          break
      }
    })
  }


  dynamic get(String key)   get (key) {
    return /** @type {MapDeltaChange<Vals[K],Modifiers> | undefined} */ (this.changes[key])
  }


  dynamic has(String key)   has (key) {
    return this.changes.containsKey(key)
  }


  dynamic equals(dynamic other)   equals (other) {
    return this[traits.EqualityTraitSymbol](other)
  }


  dynamic toJSON()   toJSON () {
    /**
     * @type {s.Unwrap<typeof mapDeltaJsonSchema>}
     */
    const changes = {}
    this.changes.forEach((change, key) => {
      changes[/** @type {string} */ (key)] = change.toJSON()
    })
    return changes
  }


  dynamic ()   [Symbol.iterator] () {
    // @ts-ignore
    return this.changes.entries()
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return fun.equalityDeep(this.changes, other.changes)
  }


  dynamic done()   done () {
    return this
  }


}


const Map<String, dynamic> changes = <String, dynamic>{};

class XmlDelta extends AbstractDelta {
  constructor(String nodeName, dynamic children, dynamic attributes)   constructor (nodeName, children, attributes) {
    super()
    this.nodeName = nodeName
    /**
     * @type {ArrayDeltaBuilder<Children,ChildModifiers>}
     */
    this.children = children
    /**
     * @type {Done extends 'mutable' ? MapDeltaBuilder<Attrs> : MapDelta<Attrs,AttrModifiers>}
     */
    this.attributes = /** @type {any} */ (attributes)
  }


  dynamic toJSON()   toJSON () {
    return {
      nodeName: this.nodeName,
      children: this.children.toJSON(),
      attributes: this.attributes.toJSON()
    }
  }


  dynamic done()   done () {
    this.children.done()
    this.attributes.done()
    return /** @type {any} */ (this)
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.nodeName == other.nodeName && this.children[traits.EqualityTraitSymbol](other.children) && this.attributes[traits.EqualityTraitSymbol](other.attributes)
  }


}


class MapDeltaBuilder extends MapDelta {
  dynamic modify(String key, dynamic delta)   modify (key, delta) {
    this.changes[key] = /** @type {any} */ ({ type: 'modify', delta })
    return this
  }


  dynamic set(String key, dynamic newVal, dynamic prevValue = undefined, dynamic attribution = null)   set (key, newVal, prevValue = undefined, attribution = null) {
    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)
    this.changes[key] = new MapInsertOp(newVal, prevValue, mergedAttribution)
    return this
  }


  dynamic delete(String key, dynamic prevValue = undefined, dynamic attribution = null)   delete (key, prevValue = undefined, attribution = null) {
    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)
    this.changes[key] = new MapDeleteOp(prevValue, mergedAttribution)
    return this
  }


  dynamic useAttribution(dynamic attribution)   useAttribution (attribution) {
    this.usedAttribution = attribution
    return this
  }


}


const dynamic mergedAttribution = mergeAttrs(this.usedAttribution, attribution);

const dynamic mergedAttribution = mergeAttrs(this.usedAttribution, attribution);

const dynamic mergeAttrs = (a, b) => object.isEmpty(a) ? b : (object.isEmpty(b) ? a : object.assign({}, a, b));

class AbstractArrayDeltaBuilder extends AbstractArrayDelta {
  constructor(dynamic type)   constructor (type) {
    super(type)
    /**
     * @type {FormattingAttributes?}
     */
    this.usedAttributes = null
    /**
     * @type {Attribution_?}
     */
    this.usedAttribution = null
    /**
     * @type {TDeltaOp?}
     */
    this.lastOp = null
  }


  dynamic useAttributes(dynamic attributes)   useAttributes (attributes) {
    this.usedAttributes = attributes
    return this
  }


  dynamic updateUsedAttributes(String name, dynamic value)   updateUsedAttributes (name, value) {
    if (value == null) {
      this.usedAttributes = object.assign({}, this.usedAttributes)
      delete this.usedAttributes?.[name]
      if (object.isEmpty(this.usedAttributes)) {
        this.usedAttributes = null
      }
    } else if (!fun.equalityDeep(this.usedAttributes?.[name], value)) {
      this.usedAttributes = object.assign({}, this.usedAttributes)
      this.usedAttributes[name] = value
    }
    return this
  }


  dynamic updateUsedAttribution(String name, dynamic value)   updateUsedAttribution (name, value) {
    if (value == null) {
      this.usedAttribution = object.assign({}, this.usedAttribution)
      delete this.usedAttribution?.[name]
      if (object.isEmpty(this.usedAttribution)) {
        this.usedAttribution = null
      }
    } else if (!fun.equalityDeep(this.usedAttribution?.[name], value)) {
      this.usedAttribution = object.assign({}, this.usedAttribution)
      this.usedAttribution[name] = value
    }
    return this
  }


  dynamic useAttribution(dynamic attribution)   useAttribution (attribution) {
    this.usedAttribution = attribution
    return this
  }


  void ()    * @param {(TDeltaOp extends InsertStringOp ? string : never) | (TDeltaOp extends InsertEmbedOp<infer Embeds> ? (Embeds) : never) | (TDeltaOp extends InsertArrayOp<infer Content> ? Array<Content> : never) } insert


  dynamic insert(dynamic insert, dynamic attributes = null, dynamic attribution = null)   insert (insert, attributes = null, attribution = null) {
    const mergedAttributes = mergeAttrs(this.usedAttributes, attributes)
    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)
    if (((this.lastOp instanceof InsertStringOp && insert.constructor == String) || (this.lastOp instanceof InsertArrayOp && insert.constructor == Array)) && (mergedAttributes == this.lastOp.attributes || fun.equalityDeep(mergedAttributes, this.lastOp.attributes)) && (mergedAttribution == this.lastOp.attribution || fun.equalityDeep(mergedAttribution, this.lastOp.attribution))) {
      // @ts-ignore
      if (insert.constructor == String) {
        // @ts-ignore
        this.lastOp.insert += insert
      } else {
        // @ts-ignore
        this.lastOp.insert.add(...insert)
      }
    } else {
      const OpConstructor = /** @type {any} */ (insert.constructor == String ? InsertStringOp : (insert.constructor == Array ? InsertArrayOp : InsertEmbedOp))
      this.ops.add(this.lastOp = new OpConstructor(insert, object.isEmpty(mergedAttributes) ? null : mergedAttributes, object.isEmpty(mergedAttribution) ? null : mergedAttribution))
    }
    return this
  }


  dynamic retain(dynamic retain, dynamic attributes = null, dynamic attribution = null)   retain (retain, attributes = null, attribution = null) {
    const mergedAttributes = mergeAttrs(this.usedAttributes, attributes)
    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)
    if (this.lastOp instanceof RetainOp && fun.equalityDeep(mergedAttributes, this.lastOp.attributes) && fun.equalityDeep(mergedAttribution, this.lastOp.attribution)) {
      this.lastOp.retain += retain
    } else {
      // @ts-ignore
      this.ops.add(this.lastOp = new RetainOp(retain, mergedAttributes, mergedAttribution))
    }
    return this
  }


  dynamic delete(dynamic len)   delete (len) {
    if (this.lastOp instanceof DeleteOp) {
      this.lastOp.delete += len
    } else {
      // @ts-ignore
      this.ops.add(this.lastOp = new DeleteOp(len))
    }
    return this
  }


  dynamic ()    * @return {Type extends 'array' ? ArrayDelta<TDeltaOp,Modifiers> : (Type extends 'text' ? TextDelta<TDeltaOp,Modifiers> : AbstractArrayDelta<Type,TDeltaOp,Modifiers>)}


  dynamic done()   done () {
    while (this.lastOp != null && this.lastOp instanceof RetainOp && this.lastOp.attributes == null && this.lastOp.attribution == null) {
      this.ops.removeLast()
      this.lastOp = this.ops[this.ops.length - 1] ?? null
    }
    return /** @type {any} */ (this)
  }


}


const dynamic mergedAttributes = mergeAttrs(this.usedAttributes, attributes);

const dynamic mergedAttribution = mergeAttrs(this.usedAttribution, attribution);

const dynamic OpConstructor = /** @type {any} */ (insert.constructor === String ? InsertStringOp : (insert.constructor === Array ? InsertArrayOp : InsertEmbedOp));

const dynamic mergedAttributes = mergeAttrs(this.usedAttributes, attributes);

const dynamic mergedAttribution = mergeAttrs(this.usedAttribution, attribution);

class ArrayDeltaBuilder extends AbstractArrayDeltaBuilder {
  constructor()   constructor () {
    super('array')
  }


}


class TextDeltaBuilder extends AbstractArrayDeltaBuilder {
  constructor()   constructor () {
    super('text')
  }


}


const dynamic d = AbstractArrayDeltaBuilder(type);

const dynamic op = /** @type {any} */ (ops[i]);

