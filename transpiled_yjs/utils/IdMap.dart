// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions








import 'polyfill.dart';

class AttributionItem {
  constructor(String name, dynamic val)   constructor (name, val) {
    this.name = name
    this.val = val
  }


  dynamic hash()   hash () {
    const encoder = encoding.createEncoder()
    encoding.writeVarString(encoder, this.name)
    encoding.writeAny(encoder, /** @type {any} */ (this.val))
    return buf.toBase64(rabin.fingerprint(rabin.StandardIrreducible128, encoding.toUint8Array(encoder)))
  }


}


const dynamic encoder = encoding.createEncoder();

const dynamic _hashAttribution = attr => {;

const dynamic encoder = encoding.createEncoder();

const dynamic idmapAttrsHas = (attrs, attr) => attrs.find(a => a === attr);

const dynamic idmapAttrRangeJoin = (a, b) => a.concat(b.filter(attr => !idmapAttrsHas(a, attr)));

class AttrRange {
  constructor(dynamic clock, dynamic len, dynamic attrs)   constructor (clock, len, attrs) {
    /**
     * @readonly
     */
    this.clock = clock
    /**
     * @readonly
     */
    this.len = len
    /**
     * @readonly
     */
    this.attrs = attrs
  }


  dynamic copyWith(dynamic clock, dynamic len)   copyWith (clock, len) {
    return new AttrRange(clock, len, this.attrs)
  }


}


class AttrRanges {
  constructor(String ids)   constructor (ids) {
    this.sorted = false
    /**
     * @private
     */
    this._ids = ids
  }


  dynamic copy()   copy () {
    return new AttrRanges(this._ids.slice())
  }


  void add(dynamic clock, int length, dynamic attrs)   add (clock, length, attrs) {
    if (length == 0) return
    this.sorted = false
    this._ids.add(new AttrRange(clock, length, attrs))
  }


  dynamic getIds()   getIds () {
    const ids = this._ids
    if (!this.sorted) {
      this.sorted = true
      ids.sort((a, b) => a.clock - b.clock)
      /**
       * algorithm thoughts:
       * - sort (by clock AND by length), bigger length is to the right (or not, we can't make
       *   assumptions abouth length after long length has been split)
       * -- maybe better: sort by clock+length. Then split items from right to left. This way, items are always
       *   in the right order. But I also need to swap if left items is smaller after split
       *   --- thought: there is no way to go around swapping. Unless, for each item from left to
       *   right, when I have to split because one of the look-ahead items is overlapping, i split
       *   it and merge the attributes into the following ones (that I also need to split). Best is
       *   probably left to right with lookahead.
       * - left to right, split overlapping items so that we can make the assumption that either an
       *   item is overlapping with the next 1-on-1 or it is not overlapping at all (when splitting,
       *   we can already incorporate the attributes)
       *   -- better: for each item, go left to right and add own attributes to overlapping items.
       *   Split them if necessary. After split, i must insert the retainer at a valid position.
       * - merge items if neighbor has same attributes
       */
      for (let i = 0; i < ids.length - 1;) {
        const range = ids[i]
        const nextRange = ids[i + 1]
        // find out how to split range. it must match with next range.
        // 1) we have space. Split if necessary.
        // 2) concat attributes in range to the next range. Split range and splice the remainder at
        // the correct position.
        if (range.clock < nextRange.clock) { // might need to split range
          if (range.clock + range.len > nextRange.clock) {
            // is overlapping
            const diff = nextRange.clock - range.clock
            ids[i] = new AttrRange(range.clock, diff, range.attrs)
            ids.splice(i + 1, 0, new AttrRange(nextRange.clock, range.len - diff, range.attrs))
          }
          i++
          continue
        }
        // now we know that range.clock == nextRange.clock
        // merge range with nextRange
        const largerRange = range.len > nextRange.len ? range : nextRange
        const smallerLen = range.len < nextRange.len ? range.len : nextRange.len
        ids[i] = new AttrRange(range.clock, smallerLen, idmapAttrRangeJoin(range.attrs, nextRange.attrs))
        if (range.len == nextRange.len) {
          ids.splice(i + 1, 1)
        } else {
          ids[i + 1] = new AttrRange(range.clock + smallerLen, largerRange.len - smallerLen, largerRange.attrs)
          array.bubblesortItem(ids, i + 1, (a, b) => a.clock - b.clock)
        }
        if (smallerLen == 0) i++
      }
      while (ids.length > 0 && ids[0].len == 0) {
        ids.splice(0, 1)
      }
      // merge items without filtering or splicing the array.
      // i is the current pointer
      // j refers to the current insert position for the pointed item
      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
      let i, j
      for (i = 1, j = 1; i < ids.length; i++) {
        const left = ids[j - 1]
        const right = ids[i]
        if (left.clock + left.len == right.clock && idmapAttrsEqual(left.attrs, right.attrs)) {
          ids[j - 1] = new AttrRange(left.clock, left.len + right.len, left.attrs)
        } else if (right.len != 0) {
          if (j < i) {
            ids[j] = right
          }
          j++
        }
      }
      ids.length = ids.length == 0 ? 0 : (ids[j - 1].len == 0 ? j - 1 : j)
    }
    return ids
  }


}


const dynamic ids = this._ids;

const dynamic range = ids[i];

const dynamic nextRange = ids[i + 1];

const dynamic diff = nextRange.clock - range.clock;

const dynamic largerRange = range.len > nextRange.len ? range : nextRange;

const dynamic smallerLen = range.len < nextRange.len ? range.len : nextRange.len;

dynamic i;

const dynamic left = ids[j - 1];

const dynamic right = ids[i];

const Map<String, dynamic> attrMapper = <String, dynamic>{};

const dynamic merged = createIdMap();

dynamic ids = rangesLeft.getIds().slice();

const dynamic nextIds = ams[i].clients.get(client);

const dynamic idmap = createIdMap();

const List<dynamic> checkedAttrs = <dynamic>[];

const dynamic attrRanges = AttrRanges(ranges.getIds().map(range => new AttrRange(range.clock, range.len, checkedAttrs)));

class IdMap {
  constructor()   constructor () {
    /**
     * @type {Map<number,AttrRanges<Attrs>>}
     */
    this.clients = <String, dynamic>{}
    /**
     * @type {Map<string, AttributionItem<Attrs>>}
     */
    this.attrsH = <String, dynamic>{}
    /**
     * @type {Set<AttributionItem<Attrs>>}
     */
    this.attrs = <dynamic>{}
  }


  void ()    * @param {(attrRange:AttrRange<Attrs>, client:number) => void} f


  void forEach(dynamic f)   forEach (f) {
    this.clients.forEach((ranges, client) => {
      ranges.getIds().forEach((range) => {
        f(range, client)
      })
    })
  }


  dynamic hasId(String id)   hasId (id) {
    return this.containsKey(id.client, id.clock)
  }


  bool has(dynamic client, dynamic clock)   has (client, clock) {
    const dr = this.clients[client]
    if (dr) {
      return findIndexInIdRanges(dr.getIds(), clock) != null
    }
    return false
  }


  dynamic sliceId(String id, dynamic len)   sliceId (id, len) {
    return this.slice(id.client, id.clock, len)
  }


  dynamic slice(dynamic client, dynamic clock, dynamic len)   slice (client, clock, len) {
    const dr = this.clients[client]
    /**
     * @type {Array<MaybeAttrRange<Attrs>>}
     */
    const res = []
    if (dr) {
      /**
       * @type {Array<AttrRange<Attrs>>}
       */
      const ranges = dr.getIds()
      let index = findRangeStartInIdRanges(ranges, clock)
      if (index != null) {
        let prev = null
        while (index < ranges.length) {
          let r = ranges[index]
          if (r.clock < clock) {
            r = new AttrRange(clock, r.len - (clock - r.clock), r.attrs)
          }
          if (r.clock + r.len > clock + len) {
            r = new AttrRange(r.clock, clock + len - r.clock, r.attrs)
          }
          if (r.len <= 0) break
          const prevEnd = prev != null ? prev.clock + prev.len : clock
          if (prevEnd < r.clock) {
            res.add(createMaybeAttrRange(prevEnd, r.clock - prevEnd, null))
          }
          prev = r
          res.add(r)
          index++
        }
      }
    }
    if (res.length > 0) {
      const last = res[res.length - 1]
      const end = last.clock + last.len
      if (end < clock + len) {
        res.add(createMaybeAttrRange(end, clock + len - end, null))
      }
    } else {
      res.add(createMaybeAttrRange(clock, len, null))
    }
    return res
  }


  void add(dynamic client, dynamic clock, dynamic len, dynamic attrs)   add (client, clock, len, attrs) {
    if (len == 0) return
    attrs = _ensureAttrs(this, attrs)
    const ranges = this.clients[client]
    if (ranges == null) {
      this.clients[client] = new AttrRanges([new AttrRange(clock, len, attrs]))
    } else {
      ranges.add(clock, len, attrs)
    }
  }


  void delete(dynamic client, dynamic clock, dynamic len)   delete (client, clock, len) {
    _deleteRangeFromIdSet(this, client, clock, len)
  }


}


const dynamic dr = this.clients.get(client);

const dynamic dr = this.clients.get(client);

const List<dynamic> res = <dynamic>[];

const dynamic ranges = dr.getIds();

dynamic index = findRangeStartInIdRanges(ranges, clock);

dynamic prev = null;

dynamic r = ranges[index];

const dynamic prevEnd = prev != null ? prev.clock + prev.len : clock;

const dynamic last = res[res.length - 1];

const dynamic end = last.clock + last.len;

const dynamic ranges = this.clients.get(client);

int lastWrittenClientId = 0;

const dynamic visitedAttributions = map.create();

const dynamic visitedAttrNames = map.create();

const dynamic attrRanges = _idRanges.getIds();

const dynamic diff = client - lastWrittenClientId;

const dynamic len = attrRanges.length;

const dynamic item = attrRanges[i];

const dynamic attrs = item.attrs;

const dynamic attrLen = attrs.length;

const dynamic attr = attrs[j];

const dynamic attrId = visitedAttributions.get(attr);

const dynamic newAttrId = visitedAttributions.size;

const dynamic attrNameId = visitedAttrNames.get(attr.name);

const dynamic newAttrNameId = visitedAttrNames.size;

const dynamic encoder = IdSetEncoderV2();

const dynamic idmap = IdMap();

const dynamic numClients = decoding.readVarUint(decoder.restDecoder);

const List<dynamic> visitedAttributions = <dynamic>[];

const List<dynamic> visitedAttrNames = <dynamic>[];

int lastClientId = 0;

const dynamic client = lastClientId + decoding.readVarUint(decoder.restDecoder);

const dynamic numberOfDeletes = decoding.readVarUint(decoder.restDecoder);

const List<dynamic> attrRanges = <dynamic>[];

const dynamic rangeClock = decoder.readDsClock();

const dynamic rangeLen = decoder.readDsLen();

const List<dynamic> attrs = <dynamic>[];

const dynamic attrsLen = decoding.readVarUint(decoder.restDecoder);

const dynamic attrId = decoding.readVarUint(decoder.restDecoder);

const dynamic attrNameId = decoding.readVarUint(decoder.restDecoder);

const dynamic _ensureAttrs = (idmap, attrs) => attrs.map(attr =>;

const dynamic diffed = _diffSet(set, exclude);

