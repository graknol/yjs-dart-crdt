// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions





import 'polyfill.dart';

class YXmlTreeWalker {
  void function(dynamic AbstractType<any>)    * @param {function(AbstractType<any>):boolean} [f]


  constructor(dynamic root, dynamic f = ()   constructor (root, f = () => true) {
    this._filter = f
    this._root = root
    /**
     * @type {Item}
     */
    this._currentNode = /** @type {Item} */ (root._start)
    this._firstCall = true
    root.doc ?? warnPrematureAccess()
  }


  dynamic ()   [Symbol.iterator] () {
    return this
  }


  dynamic next()   next () {
    /**
     * @type {Item|null}
     */
    let n = this._currentNode
    let type = n && n.content && /** @type {any} */ (n.content).type
    if (n != null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item
      do {
        type = /** @type {any} */ (n.content).type
        if (!n.deleted && (type.constructor == YXmlElement || type.constructor == YXmlFragment) && type._start != null) {
          // walk down in the tree
          n = type._start
        } else {
          // walk right or up in the tree
          while (n != null) {
            /**
             * @type {Item | null}
             */
            const nxt = n.next
            if (nxt != null) {
              n = nxt
              break
            } else if (n.parent == this._root) {
              n = null
            } else {
              n = /** @type {AbstractType<any>} */ (n.parent)._item
            }
          }
        }
      } while (n != null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))
    }
    this._firstCall = false
    if (n == null) {
      // @ts-ignore
      return { value: undefined, done: true }
    }
    this._currentNode = n
    return { value: /** @type {any} */ (n.content).type, done: false }
  }


}


dynamic n = this._currentNode;

dynamic type = n && n.content && /** @type {any} */ (n.content).type;

const dynamic nxt = n.next;

class YXmlFragment extends AbstractType {
  dynamic * const walker = elem.createTreeWalker(dom;
  Map<String, dynamic> * @param {Object<string, any>} [hooks = {}] Optional property to customize how hooks;
  dynamic * @param {number} [length = 1] The number of elements to remove. Defaults to 1.;

  constructor()   constructor () {
    super()
    /**
     * @type {Array<any>|null}
     */
    this._prelimContent = []
  }


  dynamic firstChild()   get firstChild () {
    const first = this._first
    return first ? first.content.getContent()[0] : null
  }


  void _integrate(dynamic y, dynamic item)   _integrate (y, item) {
    super._integrate(y, item)
    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))
    this._prelimContent = null
  }


  dynamic _copy()   _copy () {
    return new YXmlFragment()
  }


  dynamic clone()   clone () {
    const el = new YXmlFragment()
    // @ts-ignore
    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item))
    return el
  }


  dynamic length()   get length () {
    this.doc ?? warnPrematureAccess()
    return this._prelimContent == null ? this._length : this._prelimContent.length
  }


  void for(dynamic let node in walker)    * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }


  void function(dynamic AbstractType<any>)    * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and


  dynamic createTreeWalker(dynamic filter)   createTreeWalker (filter) {
    return new YXmlTreeWalker(this, filter)
  }


  void querySelector(dynamic query)   querySelector (query) {
    query = query.toUpperCase()
    // @ts-ignore
    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() == query)
    const next = iterator.next()
    if (next.done) {
      return null
    } else {
      return next.value
    }
  }


  dynamic querySelectorAll(dynamic query)   querySelectorAll (query) {
    query = query.toUpperCase()
    // @ts-ignore
    return array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() == query))
  }


  void _callObserver(dynamic transaction, dynamic parentSubs)   _callObserver (transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction))
  }


  dynamic toString()   toString () {
    return typeListMap(this, xml => xml.toString()).join('')
  }


  dynamic toJSON()   toJSON () {
    return this.toString()
  }


  void ()    * @param {Document} [_document=document] The document object (you must define


  dynamic toDOM(dynamic _document = document, dynamic hooks = <String, dynamic>{}, dynamic binding)   toDOM (_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment()
    if (binding != undefined) {
      binding._createAssociation(fragment, this)
    }
    typeListForEach(this, xmlType => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null)
    })
    return fragment
  }


  void insert(int index, dynamic content)   insert (index, content) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        typeListInsertGenerics(transaction, this, index, content)
      })
    } else {
      // @ts-ignore _prelimContent is defined because this is not yet integrated
      this._prelimContent.splice(index, 0, ...content)
    }
  }


  void insertAfter(dynamic ref, dynamic content)   insertAfter (ref, content) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref
        typeListInsertGenericsAfter(transaction, this, refItem, content)
      })
    } else {
      const pc = /** @type {Array<any>} */ (this._prelimContent)
      const index = ref == null ? 0 : pc.findIndex(el => el == ref) + 1
      if (index == 0 && ref != null) {
        throw error.create('Reference item not found')
      }
      pc.splice(index, 0, ...content)
    }
  }


  void delete(int index, int length = 1)   delete (index, length = 1) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        typeListDelete(transaction, this, index, length)
      })
    } else {
      // @ts-ignore _prelimContent is defined because this is not yet integrated
      this._prelimContent.splice(index, length)
    }
  }


  dynamic toArray()   toArray () {
    return typeListToArray(this)
  }


  void import(dynamic '../internals.js')    * @param {import('../internals.js').AbstractAttributionManager} am


  dynamic import(dynamic '../utils/Delta.js')    * @return {{ children: import('../utils/Delta.js').ArrayDeltaBuilderBuilder<Array<YXmlElement|YXmlText|YXmlHook>> }}


  dynamic getContent(dynamic am = noAttributionsManager)   getContent (am = noAttributionsManager) {
    const children = typeListGetContent(this, am)
    return { children }
  }


  void import(dynamic '../internals.js')    * @param {import('../internals.js').AbstractAttributionManager} am


  dynamic import(dynamic '../utils/Delta.js')    * @return {{ children: import('../utils/Delta.js').ArrayDeltaBuilderBuilder<Array<import('./AbstractType.js').YXmlDeepContent>> }}


  dynamic getContentDeep(dynamic am)   getContentDeep (am) {
    const { children: origChildren } = this.getContent(am)
    /**
     * @type {import('../utils/Delta.js').ArrayDeltaBuilderBuilder<Array<import('./AbstractType.js').YXmlDeepContent>>}
     */
    const children = origChildren.map(d => /** @type {any} */ (
      d instanceof delta.InsertArrayOp && d.insert instanceof Array
        ? new delta.InsertArrayOp(d.insert.map(e => e instanceof AbstractType ? e.getContentDeep(am) : e), d.attributes, d.attribution)
        : d
    ))
    return { children }
  }


  void push(dynamic content)   push (content) {
    this.insert(this.length, content)
  }


  void unshift(dynamic content)   unshift (content) {
    this.insert(0, content)
  }


  dynamic get(int index)   get (index) {
    return typeListGet(this, index)
  }


  dynamic slice(dynamic start = 0, dynamic end = this.length)   slice (start = 0, end = this.length) {
    return typeListSlice(this, start, end)
  }


  void function(String YXmlElement|YXmlText, dynamic number, dynamic typeof self)    * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.


  void forEach(dynamic f)   forEach (f) {
    typeListForEach(this, f)
  }


  void _write(dynamic encoder)   _write (encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID)
  }


}


const dynamic first = this._first;

const dynamic el = YXmlFragment();

const dynamic iterator = YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);

const dynamic next = iterator.next();

const dynamic fragment = _document.createDocumentFragment();

const dynamic refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;

const dynamic pc = /** @type {Array<any>} */ (this._prelimContent);

const dynamic index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;

const dynamic children = typeListGetContent(this, am);

const dynamic  = null;

const dynamic children = origChildren.map(d => /** @type {any} */ (;

