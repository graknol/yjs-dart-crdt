// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions







import 'polyfill.dart';

const dynamic writeStructs = (encoder, structs, client, idranges) => {;

dynamic structsToWrite = 0 // this accounts for the skips;

const List<dynamic> indexRanges = <dynamic>[];

const dynamic firstPossibleClock = structs[0].id.clock;

const dynamic lastStruct = array.last(structs);

const dynamic lastPossibleClock = lastStruct.id.clock + lastStruct.length;

const dynamic startClock = math.max(idrange.clock, firstPossibleClock);

const dynamic endClock = math.min(idrange.clock + idrange.len, lastPossibleClock);

const dynamic start = findIndexSS(structs, startClock);

const dynamic end = findIndexSS(structs, endClock - 1) + 1;

dynamic clock = indexRanges[0].startClock;

const dynamic skipLen = indexRange.startClock - clock;

const dynamic struct = structs[i];

const dynamic structEnd = struct.id.clock + struct.length;

const dynamic offsetEnd = math.max(structEnd - indexRange.endClock, 0);

const Map<String, dynamic> sm = <String, dynamic>{};

const dynamic structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));

const dynamic lastStruct = structs[structs.length - 1];

const dynamic idRanges = ids.getIds();

const dynamic structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));

const dynamic integrateStructs = (transaction, store, clientsStructRefs) => {;

const List<dynamic> stack = <dynamic>[];

dynamic clientsStructRefsIds = array.from(clientsStructRefs.clients.keys()).sort((a, b) => a - b);

const dynamic getNextStructTarget = () => {;

dynamic nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.clients.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));

dynamic curStructsTarget = getNextStructTarget();

const dynamic restStructs = StructStore();

const Map<String, dynamic> missingSV = <String, dynamic>{};

const dynamic updateMissingSv = (client, clock) => {;

const dynamic mclock = missingSV.get(client);

dynamic stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];

const Map<String, dynamic> state = <String, dynamic>{};

const dynamic addStackToRestSS = () => {;

const dynamic client = item.id.client;

const dynamic inapplicableItems = clientsStructRefs.clients.get(client);

const dynamic localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));

const dynamic offset = localClock - stackHead.id.clock;

const dynamic missing = stackHead.getMissing(transaction, store);

const dynamic structRefs = clientsStructRefs.clients.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };

const dynamic skip = Skip(createID(stackHead.id.client, localClock), -offset);

const dynamic encoder = UpdateEncoderV2();

bool retry = false;

const dynamic doc = transaction.doc;

const dynamic store = doc.store;

const dynamic ss = readStructSet(structDecoder, doc);

const dynamic knownState = createIdSet();

const dynamic storeStructs = store.clients.get(client);

const dynamic last = storeStructs[storeStructs.length - 1];

const dynamic restStructs = integrateStructs(transaction, store, ss);

const dynamic pending = store.pendingStructs;

const dynamic mclock = pending.missing.get(client);

const dynamic dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);

const dynamic pendingDSUpdate = UpdateDecoderV2(decoding.createDecoder(store.pendingDs));

const dynamic dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);

const dynamic update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;

const dynamic decoder = decoding.createDecoder(update);

const dynamic targetStateVector = decodeStateVector(encodedTargetStateVector);

const dynamic updates = [encoder.toUint8Array()];

const Map<String, dynamic> ss = <String, dynamic>{};

const dynamic ssLength = decoding.readVarUint(decoder.restDecoder);

const dynamic client = decoding.readVarUint(decoder.restDecoder);

const dynamic clock = decoding.readVarUint(decoder.restDecoder);

