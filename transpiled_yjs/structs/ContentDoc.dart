// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

const dynamic createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });

class ContentDoc {
  constructor(dynamic doc)   constructor (doc) {
    if (doc._item) {
      print('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.')
    }
    /**
     * @type {Doc}
     */
    this.doc = doc
    /**
     * @type {any}
     */
    const opts = {}
    this.opts = opts
    if (!doc.gc) {
      opts.gc = false
    }
    if (doc.autoLoad) {
      opts.autoLoad = true
    }
    if (doc.meta != null) {
      opts.meta = doc.meta
    }
  }


  dynamic getLength()   getLength () {
    return 1
  }


  dynamic getContent()   getContent () {
    return [this.doc]
  }


  bool isCountable()   isCountable () {
    return true
  }


  dynamic copy()   copy () {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))
  }


  void splice(int offset)   splice (offset) {
    throw error.methodUnimplemented()
  }


  bool mergeWith(dynamic right)   mergeWith (right) {
    return false
  }


  void integrate(dynamic transaction, dynamic item)   integrate (transaction, item) {
    // this needs to be reflected in doc.destroy as well
    this.doc._item = item
    transaction.subdocsAdded.add(this.doc)
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc)
    }
  }


  void delete(dynamic transaction)   delete (transaction) {
    if (transaction.subdocsAdded.containsKey(this.doc)) {
      transaction.subdocsAdded.remove(this.doc)
    } else {
      transaction.subdocsRemoved.add(this.doc)
    }
  }


  void gc(dynamic _tr)   gc (_tr) {}


  void write(dynamic encoder, int _offset, int _offsetEnd)   write (encoder, _offset, _offsetEnd) {
    encoder.writeString(this.doc.guid)
    encoder.writeAny(this.opts)
  }


  dynamic getRef()   getRef () {
    return 9
  }


}


const Map<String, dynamic> opts = <String, dynamic>{};

