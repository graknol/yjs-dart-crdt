// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

const dynamic numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);

const dynamic numberOfStructs = decoding.readVarUint(decoder.restDecoder);

const dynamic client = decoder.readClient();

dynamic clock = decoding.readVarUint(decoder.restDecoder);

const dynamic info = decoder.readInfo();

const dynamic len = decoding.readVarUint(decoder.restDecoder);

const dynamic cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;

const dynamic struct = Item(;

const dynamic len = decoder.readLen();

class LazyStructReader {
  constructor(dynamic decoder, dynamic filterSkips)   constructor (decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder)
    /**
     * @type {null | Item | Skip | GC}
     */
    this.curr = null
    this.done = false
    this.filterSkips = filterSkips
    this.next()
  }


  dynamic next()   next () {
    // ignore "Skip" structs
    do {
      this.curr = this.gen.next().value || null
    } while (this.filterSkips && this.curr != null && this.curr.constructor == Skip)
    return this.curr
  }


}


const List<dynamic> structs = <dynamic>[];

const dynamic updateDecoder = YDecoder(decoding.createDecoder(update));

const dynamic lazyDecoder = LazyStructReader(updateDecoder, false);

const dynamic ds = readIdSet(updateDecoder);

const List<dynamic> structs = <dynamic>[];

const dynamic updateDecoder = YDecoder(decoding.createDecoder(update));

const dynamic lazyDecoder = LazyStructReader(updateDecoder, false);

class LazyStructWriter {
  constructor(dynamic encoder)   constructor (encoder) {
    this.currClient = 0
    this.startClock = 0
    this.written = 0
    this.encoder = encoder
    /**
     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
     *
     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
     *
     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
     *
     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
     */
    this.clientStructs = []
  }


}


const dynamic encoder = YEncoder();

const dynamic updateDecoder = LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);

dynamic curr = updateDecoder.curr;

int size = 0;

dynamic currClient = curr.id.client;

dynamic stopCounting = curr.id.clock !== 0 // must start at 0;

dynamic currClock = stopCounting ? 0 : curr.id.clock + curr.length;

const dynamic enc = encoding.createEncoder();

const Map<String, dynamic> from = <String, dynamic>{};

const Map<String, dynamic> to = <String, dynamic>{};

const dynamic updateDecoder = LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);

dynamic curr = updateDecoder.curr;

dynamic currClient = curr.id.client;

dynamic currClock = curr.id.clock;

const dynamic sliceStruct = (left, diff) => {;

const dynamic  = null;

const dynamic  = null;

const dynamic leftItem = /** @type {Item} */ (left);

const dynamic  = null;

const dynamic updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)));

dynamic lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));

dynamic currWrite = null;

const dynamic updateEncoder = YEncoder();

const dynamic lazyStructEncoder = LazyStructWriter(updateEncoder);

const dynamic clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;

const dynamic currDecoder = lazyStructDecoders[0];

const dynamic firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;

dynamic curr = /** @type {Item | GC | null} */ (currDecoder.curr);

bool iterated = false;

const dynamic diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;

const dynamic struct = Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);

const dynamic diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;

dynamic next = currDecoder.curr;

const dynamic dss = updateDecoders.map(decoder => readIdSet(decoder));

const dynamic ds = mergeIdSets(dss);

const dynamic state = decodeStateVector(sv);

const dynamic encoder = YEncoder();

const dynamic lazyStructWriter = LazyStructWriter(encoder);

const dynamic decoder = YDecoder(decoding.createDecoder(update));

const dynamic reader = LazyStructReader(decoder, false);

const dynamic curr = reader.curr;

const dynamic currClient = curr.id.client;

const dynamic svClock = state.get(currClient) || 0;

const dynamic ds = readIdSet(decoder);

const dynamic flushLazyStructWriter = lazyWriter => {;

const dynamic writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {;

const dynamic finishLazyStructWriting = (lazyWriter) => {;

const dynamic restEncoder = lazyWriter.encoder.restEncoder;

const dynamic partStructs = lazyWriter.clientStructs[i];

const dynamic updateDecoder = YDecoder(decoding.createDecoder(update));

const dynamic lazyDecoder = LazyStructReader(updateDecoder, false);

const dynamic updateEncoder = YEncoder();

const dynamic lazyWriter = LazyStructWriter(updateEncoder);

const dynamic ds = readIdSet(updateDecoder);

const dynamic createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {;

int i = 0;

const dynamic mapKeyCache = map.create();

const dynamic nodeNameCache = map.create();

const dynamic formattingKeyCache = map.create();

const dynamic formattingValueCache = map.create();

const dynamic item = /** @type {Item} */ (block);

const dynamic content = item.content;

const dynamic type = /** @type {ContentType} */ (content).type;

const dynamic c = /** @type {ContentAny} */ (content);

const dynamic c = /** @type {ContentBinary} */ (content);

const dynamic c = /** @type {ContentDoc} */ (content);

const dynamic c = /** @type {ContentEmbed} */ (content);

const dynamic c = /** @type {ContentFormat} */ (content);

const dynamic c = /** @type {ContentJSON} */ (content);

const dynamic c = /** @type {ContentString} */ (content);

