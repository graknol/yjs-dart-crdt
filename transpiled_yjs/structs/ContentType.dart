// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class ContentType {
  constructor(dynamic type)   constructor (type) {
    /**
     * @type {AbstractType<any>}
     */
    this.type = type
  }


  dynamic getLength()   getLength () {
    return 1
  }


  dynamic getContent()   getContent () {
    return [this.type]
  }


  bool isCountable()   isCountable () {
    return true
  }


  dynamic copy()   copy () {
    return new ContentType(this.type._copy())
  }


  void splice(int _offset)   splice (_offset) {
    throw error.methodUnimplemented()
  }


  bool mergeWith(dynamic _right)   mergeWith (_right) {
    return false
  }


  void integrate(dynamic transaction, dynamic item)   integrate (transaction, item) {
    this.type._integrate(transaction.doc, item)
  }


  void delete(dynamic transaction)   delete (transaction) {
    let item = this.type._start
    while (item != null) {
      if (!item.deleted) {
        item.remove(transaction)
      } else if (!transaction.insertSet.hasId(item.id)) {
        // This will be gc'd later and we want to merge it if possible
        // We try to merge all deleted items after each transaction,
        // but we have no knowledge about that this needs to be merged
        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
        transaction._mergeStructs.add(item)
      }
      item = item.right
    }
    this.type._map.forEach(item => {
      if (!item.deleted) {
        item.remove(transaction)
      } else if (!transaction.insertSet.hasId(item.id)) {
        // same as above
        transaction._mergeStructs.add(item)
      }
    })
    transaction.changed.remove(this.type)
  }


  void gc(dynamic tr)   gc (tr) {
    let item = this.type._start
    while (item != null) {
      item.gc(tr, true)
      item = item.right
    }
    this.type._start = null
    this.type._map.forEach(/** @param {Item | null} item */ (item) => {
      while (item != null) {
        item.gc(tr, true)
        item = item.left
      }
    })
    this.type._map = <String, dynamic>{}
  }


  void write(dynamic encoder, int _offset, int _offsetEnd)   write (encoder, _offset, _offsetEnd) {
    this.type._write(encoder)
  }


  dynamic getRef()   getRef () {
    return 7
  }


}


dynamic item = this.type._start;

dynamic item = this.type._start;

