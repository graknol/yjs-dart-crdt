// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions





import 'polyfill.dart';

const dynamic clientRefs = StructSet();

const dynamic numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);

const dynamic numberOfStructs = decoding.readVarUint(decoder.restDecoder);

const List<dynamic> refs = <dynamic>[];

const dynamic client = decoder.readClient();

dynamic clock = decoding.readVarUint(decoder.restDecoder);

const dynamic info = decoder.readInfo();

const dynamic len = decoder.readLen();

const dynamic len = decoding.readVarUint(decoder.restDecoder);

const dynamic cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;

const dynamic struct = Item(;

const dynamic structs = /** @type {StructRange} */ (ss.clients.get(client))?.refs;

const dynamic firstStruct = structs[0];

const dynamic lastStruct = structs[structs.length - 1];

const dynamic idranges = range.getIds();

const dynamic range = idranges[i];

int startIndex = 0;

dynamic endIndex = structs.length // must be set here, after structs is modified;

const dynamic d = endIndex - startIndex;

class StructRange {
  constructor(dynamic refs)   constructor (refs) {
    this.i = 0
    /**
     * @type {Array<Item | GC>}
     */
    this.refs = refs
  }


}


class StructSet {
  constructor()   constructor () {
    /**
     * @type {Map<number, StructRange>}
     */
    this.clients = map.create()
  }


}


