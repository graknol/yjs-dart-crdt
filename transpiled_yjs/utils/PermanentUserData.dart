// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions



import 'polyfill.dart';

class PermanentUserData {
  constructor(dynamic doc, dynamic storeType = doc.getMap('users')   constructor (doc, storeType = doc.getMap('users')) {
    /**
     * @type {Map<string,IdSet>}
     */
    const dss = <String, dynamic>{}
    this.yusers = storeType
    this.doc = doc
    /**
     * Maps from clientid to userDescription
     *
     * @type {Map<number,string>}
     */
    this.clients = <String, dynamic>{}
    this.dss = dss
    /**
     * @param {YMap<any>} user
     * @param {string} userDescription
     */
    const initUser = (user, userDescription) => {
      /**
       * @type {YArray<Uint8Array>}
       */
      const ds = user['ds']
      const ids = user['ids']
      const addClientId = /** @param {number} clientid */ clientid => this.clients[clientid] = userDescription
      ds.observe(/** @param {YArrayEvent<any>} event */ event => {
        event.changes.added.forEach(item => {
          item.content.getContent().forEach(encodedDs => {
            if (encodedDs instanceof Uint8Array) {
              this.dss[userDescription] = mergeIdSets([this.dss[userDescription || createIdSet(], readIdSet(new DSDecoderV1(decoding.createDecoder(encodedDs)))]))
            }
          })
        })
      })
      this.dss[userDescription] = mergeIdSets(ds.map(encodedDs => readIdSet(new DSDecoderV1(decoding.createDecoder(encodedDs)))))
      ids.observe(/** @param {YArrayEvent<any>} event */ event =>
        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))
      )
      ids.forEach(addClientId)
    }
    // observe users
    storeType.observe(event => {
      event.keysChanged.forEach(userDescription =>
        initUser(storeType[userDescription], userDescription)
      )
    })
    // add initial data
    storeType.forEach(initUser)
  }


  void function(dynamic Transaction, String IdSet)    * @param {function(Transaction, IdSet):boolean} [conf.filter]


  void setUserMapping(dynamic doc, String clientid, dynamic userDescription, dynamic { filter = () // PLACEHOLDER: Timer functionality needs manual implementation
// PLACEHOLDER: Add import 'dart:async'; for Timer
  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {
    const users = this.yusers
    let user = users[userDescription]
    if (!user) {
      user = new YMap()
      user['ids'] = new YArray()
      user['ds'] = new YArray()
      users[userDescription] = user
    }
    user['ids'].add([clientid])
    users.observe(_event => {
      setTimeout(() => {
        const userOverwrite = users[userDescription]
        if (userOverwrite != user) {
          // user was overwritten, port all data over to the next user object
          // @todo Experiment with Y.Sets here
          user = userOverwrite
          // @todo iterate over old type
          this.clients.forEach((_userDescription, clientid) => {
            if (userDescription == _userDescription) {
              user['ids'].add([clientid])
            }
          })
          const encoder = new IdSetEncoderV1()
          const ds = this.dss[userDescription]
          if (ds) {
            writeIdSet(encoder, ds)
            user['ds'].add([encoder.toUint8Array()])
          }
        }
      }, 0)
    })
    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {
      setTimeout(() => {
        const yds = user['ds']
        const ds = transaction.deleteSet
        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
          const encoder = new IdSetEncoderV1()
          writeIdSet(encoder, ds)
          yds.add([encoder.toUint8Array()])
        }
      })
    })
  }


  dynamic getUserByClientId(String clientid)   getUserByClientId (clientid) {
    return this.clients[clientid] || null
  }


  void getUserByDeletedId(String id)   getUserByDeletedId (id) {
    for (const [userDescription, ds] of this.dss.entries()) {
      if (ds.hasId(id)) {
        return userDescription
      }
    }
    return null
  }


}


const Map<String, dynamic> dss = <String, dynamic>{};

const dynamic initUser = (user, userDescription) => {;

const dynamic ds = user.get('ds');

const dynamic ids = user.get('ids');

const dynamic addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);

const dynamic users = this.yusers;

dynamic user = users.get(userDescription);

const dynamic userOverwrite = users.get(userDescription);

const dynamic encoder = IdSetEncoderV1();

const dynamic ds = this.dss.get(userDescription);

const dynamic yds = user.get('ds');

const dynamic ds = transaction.deleteSet;

const dynamic encoder = IdSetEncoderV1();

