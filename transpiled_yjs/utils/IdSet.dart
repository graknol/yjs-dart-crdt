// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class IdRange {
  constructor(dynamic clock, dynamic len)   constructor (clock, len) {
    /**
     * @type {number}
     */
    this.clock = clock
    /**
     * @type {number}
     */
    this.len = len
  }


  dynamic copyWith(dynamic clock, dynamic len)   copyWith (clock, len) {
    return new IdRange(clock, len)
  }


  dynamic import(String './IdMap.js')    * @return {Array<import('./IdMap.js').AttributionItem<any>>}


  dynamic attrs()   get attrs () {
    return []
  }


}


class MaybeIdRange {
  constructor(dynamic clock, dynamic len, dynamic exists)   constructor (clock, len, exists) {
    /**
     * @type {number}
     */
    this.clock = clock
    /**
     * @type {number}
     */
    this.len = len
    /**
     * @type {boolean}
     */
    this.exists = exists
  }


}


class IdRanges {
  constructor(String ids)   constructor (ids) {
    this.sorted = false
    /**
     * A typical use-case for IdSet is to append data. We heavily optimize this case by allowing the
     * last item to be mutated ef it isn't used currently.
     * This flag is true if the last item was exposed to the outside.
     */
    this._lastIsUsed = false
    /**
     * @private
     */
    this._ids = ids
  }


  dynamic copy()   copy () {
    return new IdRanges(this._ids.slice())
  }


  void add(dynamic clock, int length)   add (clock, length) {
    const last = this._ids[this._ids.length - 1]
    if (last.clock + last.len == clock) {
      if (this._lastIsUsed) {
        this._ids[this._ids.length - 1] = new IdRange(last.clock, last.len + length)
        this._lastIsUsed = false
      } else {
        this._ids[this._ids.length - 1].len += length
      }
    } else {
      this.sorted = false
      this._ids.add(new IdRange(clock, length))
    }
  }


  dynamic getIds()   getIds () {
    const ids = this._ids
    this._lastIsUsed = true
    if (!this.sorted) {
      this.sorted = true
      ids.sort((a, b) => a.clock - b.clock)
      // merge items without filtering or splicing the array
      // i is the current pointer
      // j refers to the current insert position for the pointed item
      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
      let i, j
      for (i = 1, j = 1; i < ids.length; i++) {
        const left = ids[j - 1]
        const right = ids[i]
        if (left.clock + left.len >= right.clock) {
          const r = right.clock + right.len - left.clock
          if (left.len < r) {
            ids[j - 1] = new IdRange(left.clock, r)
          }
        } else if (left.len == 0) {
          ids[j - 1] = right
        } else {
          if (j < i) {
            ids[j] = right
          }
          j++
        }
      }
      ids.length = ids[j - 1].len == 0 ? j - 1 : j
    }
    return ids
  }


}


const dynamic last = this._ids[this._ids.length - 1];

const dynamic ids = this._ids;

dynamic i;

const dynamic left = ids[j - 1];

const dynamic right = ids[i];

const dynamic r = right.clock + right.len - left.clock;

class IdSet {
  constructor()   constructor () {
    /**
     * @type {Map<number,IdRanges>}
     */
    this.clients = <String, dynamic>{}
  }


  dynamic isEmpty()   isEmpty () {
    return this.clients.size == 0
  }


  void ()    * @param {(idrange:IdRange, client:number) => void} f


  void forEach(dynamic f)   forEach (f) {
    this.clients.forEach((ranges, client) => {
      ranges.getIds().forEach((range) => {
        f(range, client)
      })
    })
  }


  dynamic hasId(String id)   hasId (id) {
    return this.containsKey(id.client, id.clock)
  }


  bool has(dynamic client, dynamic clock)   has (client, clock) {
    const dr = this.clients[client]
    if (dr) {
      return findIndexInIdRanges(dr.getIds(), clock) != null
    }
    return false
  }


  dynamic slice(dynamic client, dynamic clock, dynamic len)   slice (client, clock, len) {
    const dr = this.clients[client]
    /**
     * @type {Array<MaybeIdRange>}
     */
    const res = []
    if (dr) {
      /**
       * @type {Array<IdRange>}
       */
      const ranges = dr.getIds()
      let index = findRangeStartInIdRanges(ranges, clock)
      if (index != null) {
        let prev = null
        while (index < ranges.length) {
          let r = ranges[index]
          if (r.clock < clock) {
            r = new IdRange(clock, r.len - (clock - r.clock))
          }
          if (r.clock + r.len > clock + len) {
            r = new IdRange(r.clock, clock + len - r.clock)
          }
          if (r.len <= 0) break
          const prevEnd = prev != null ? prev.clock + prev.len : clock
          if (prevEnd < r.clock) {
            res.add(createMaybeIdRange(prevEnd, r.clock - prevEnd, false))
          }
          prev = r
          res.add(createMaybeIdRange(r.clock, r.len, true))
          index++
        }
      }
    }
    if (res.length > 0) {
      const last = res[res.length - 1]
      const end = last.clock + last.len
      if (end < clock + len) {
        res.add(createMaybeIdRange(end, clock + len - end, false))
      }
    } else {
      res.add(createMaybeIdRange(clock, len, false))
    }
    return res
  }


  void add(dynamic client, dynamic clock, dynamic len)   add (client, clock, len) {
    addToIdSet(this, client, clock, len)
  }


  void delete(dynamic client, dynamic clock, dynamic len)   delete (client, clock, len) {
    _deleteRangeFromIdSet(this, client, clock, len)
  }


}


const dynamic dr = this.clients.get(client);

const dynamic dr = this.clients.get(client);

const List<dynamic> res = <dynamic>[];

const dynamic ranges = dr.getIds();

dynamic index = findRangeStartInIdRanges(ranges, clock);

dynamic prev = null;

dynamic r = ranges[index];

const dynamic prevEnd = prev != null ? prev.clock + prev.len : clock;

const dynamic last = res[res.length - 1];

const dynamic end = last.clock + last.len;

const dynamic dr = set.clients.get(client);

const dynamic ids = dr.getIds();

dynamic index = findRangeStartInIdRanges(ids, clock);

const dynamic ranges = idRanges.getIds();

const dynamic structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));

const dynamic del = ranges[i];

int left = 0;

dynamic right = dis.length - 1;

const dynamic midindex = math.floor((left + right) / 2);

const dynamic mid = dis[midindex];

const dynamic midclock = mid.clock;

int left = 0;

dynamic right = dis.length - 1;

const dynamic midindex = math.floor((left + right) / 2);

const dynamic mid = dis[midindex];

const dynamic midclock = mid.clock;

const dynamic merged = IdSet();

const dynamic ids = rangesLeft.getIds().slice();

const dynamic nextIds = idSets[i].clients.get(client);

const dynamic targetRanges = dest.clients.get(client);

const dynamic res = srcRanges.copy();

const dynamic res = /** @type {any } */ (set instanceof IdSet ? new IdSet() : new IdMap());

const dynamic Ranges = set instanceof IdSet ? IdRanges : AttrRanges;

List<dynamic> resRanges = <dynamic>[];

const dynamic _excludedRanges = exclude.clients.get(client);

const dynamic setRanges = _setRanges.getIds();

const dynamic excludedRanges = _excludedRanges.getIds();

dynamic i = 0 let j = 0;

dynamic currRange = setRanges[0];

const dynamic e = excludedRanges[j];

const dynamic newClock = e.clock + e.len;

const dynamic newLen = currRange.clock + currRange.len - newClock;

const dynamic nextLen = e.clock - currRange.clock;

const dynamic res = /** @type {any } */ (setA instanceof IdSet ? new IdSet() : new IdMap());

const dynamic Ranges = setA instanceof IdSet ? IdRanges : AttrRanges;

const List<dynamic> resRanges = <dynamic>[];

const dynamic _bRanges = setB.clients.get(client);

const dynamic aRanges = _aRanges.getIds();

const dynamic bRanges = _bRanges.getIds();

const dynamic aRange = aRanges[a];

const dynamic bRange = bRanges[b];

const dynamic clock = math.max(aRange.clock, bRange.clock);

const dynamic len = math.min(aRange.len - (clock - aRange.clock), bRange.len - (clock - bRange.clock));

const dynamic idRanges = idSet.clients.get(client);

const dynamic ds = createIdSet();

const List<dynamic> dsitems = <dynamic>[];

const dynamic struct = structs[i];

const dynamic clock = struct.id.clock;

dynamic len = struct.length;

const List<dynamic> iditems = <dynamic>[];

const dynamic struct = structs[i];

const dynamic clock = struct.id.clock;

dynamic len = struct.length;

const dynamic idset = createIdSet();

const dynamic iditems = _createInsertSliceFromStructs(structs, filterDeleted);

const dynamic idRanges = _idRanges.getIds();

const dynamic len = idRanges.length;

const dynamic item = idRanges[i];

const dynamic ds = IdSet();

const dynamic numClients = decoding.readVarUint(decoder.restDecoder);

const dynamic client = decoding.readVarUint(decoder.restDecoder);

const dynamic numberOfDeletes = decoding.readVarUint(decoder.restDecoder);

const List<dynamic> dsRanges = <dynamic>[];

const dynamic unappliedDS = IdSet();

const dynamic numClients = decoding.readVarUint(decoder.restDecoder);

const dynamic client = decoding.readVarUint(decoder.restDecoder);

const dynamic numberOfDeletes = decoding.readVarUint(decoder.restDecoder);

const dynamic structs = store.clients.get(client) || [];

const dynamic state = getState(store, client);

const dynamic clock = decoder.readDsClock();

const dynamic clockEnd = clock + decoder.readDsLen();

dynamic index = findIndexSS(structs, clock);

dynamic struct = structs[index];

const dynamic c = math.max(struct.id.clock, clock);

const dynamic ds = UpdateEncoderV2();

const dynamic deleteItems1 = _deleteItems1.getIds();

const dynamic deleteItems2 = ds2.clients.get(client)?.getIds();

const dynamic di1 = deleteItems1[i];

const dynamic di2 = deleteItems2[i];

