// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

const String errorComputeChanges = 'You must not compute changes after the event-handler fired.';

class YEvent {
  dynamic *   let type = y;
  dynamic *   type = ;

  constructor(dynamic target, dynamic transaction)   constructor (target, transaction) {
    /**
     * The type on which this event was created on.
     * @type {T}
     */
    this.target = target
    /**
     * The current target on which the observe callback is called.
     * @type {AbstractType<any>}
     */
    this.currentTarget = target
    /**
     * The transaction that triggered this event.
     * @type {Transaction}
     */
    this.transaction = transaction
    /**
     * @type {Object|null}
     */
    this._changes = null
    /**
     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any }>}
     */
    this._keys = null
    /**
     * @type {import('./Delta.js').TextDelta<any,undefined>?}
     */
    this._delta = null
    /**
     * @type {Array<string|number>|null}
     */
    this._path = null
  }


  void ()    *   event.path.forEach(dir => {
   *     type = type[dir]
   *   })


  dynamic path()   get path () {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target))
  }


  dynamic deletes(dynamic struct)   deletes (struct) {
    return this.transaction.deleteSet.hasId(struct.id)
  }


  dynamic keys()   get keys () {
    if (this._keys == null) {
      if (this.transaction.doc._transactionCleanups.length == 0) {
        throw error.create(errorComputeChanges)
      }
      const keys = <String, dynamic>{}
      const target = this.target
      const changed = /** @type Set<string|null> */ (this.transaction.changed[target])
      changed.forEach(key => {
        if (key != null) {
          const item = /** @type {Item} */ (target._map[key])
          /**
           * @type {'delete' | 'add' | 'update'}
           */
          let action
          let oldValue
          if (this.adds(item)) {
            let prev = item.left
            while (prev != null && this.adds(prev)) {
              prev = prev.left
            }
            if (this.deletes(item)) {
              if (prev != null && this.deletes(prev)) {
                action = 'delete'
                oldValue = array.last(prev.content.getContent())
              } else {
                return
              }
            } else {
              if (prev != null && this.deletes(prev)) {
                action = 'update'
                oldValue = array.last(prev.content.getContent())
              } else {
                action = 'add'
                oldValue = undefined
              }
            }
          } else {
            if (this.deletes(item)) {
              action = 'delete'
              oldValue = array.last(/** @type {Item} */ item.content.getContent())
            } else {
              return // nop
            }
          }
          keys[key] = { action, oldValue }
        }
      })
      this._keys = keys
    }
    return this._keys
  }


  void import(dynamic './Delta.js')    * @type {import('./Delta.js').Delta}


  dynamic delta()   get delta () {
    return this.changes.delta
  }


  dynamic adds(dynamic struct)   adds (struct) {
    return this.transaction.insertSet.hasId(struct.id)
  }


  void import(dynamic './Delta.js')    * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:import('./Delta.js').Delta}}


  dynamic changes()   get changes () {
    let changes = this._changes
    if (changes == null) {
      if (this.transaction.doc._transactionCleanups.length == 0) {
        throw error.create(errorComputeChanges)
      }
      const target = this.target
      const added = set.create()
      const deleted = set.create()
      /**
       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
       */
      const delta = []
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      }
      const changed = /** @type Set<string|null> */ (this.transaction.changed[target])
      if (changed.containsKey(null)) {
        /**
         * @type {any}
         */
        let lastOp = null
        const packOp = () => {
          if (lastOp) {
            delta.add(lastOp)
          }
        }
        for (let item = target._start; item != null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp == null || lastOp.delete == undefined) {
                packOp()
                lastOp = { delete: 0 }
              }
              lastOp.delete += item.length
              deleted.add(item)
            } // else nop
          } else {
            if (this.adds(item)) {
              if (lastOp == null || lastOp.insert == undefined) {
                packOp()
                lastOp = { insert: [] }
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent())
              added.add(item)
            } else {
              if (lastOp == null || lastOp.retain == undefined) {
                packOp()
                lastOp = { retain: 0 }
              }
              lastOp.retain += item.length
            }
          }
        }
        if (lastOp != null && lastOp.retain == undefined) {
          packOp()
        }
      }
      this._changes = changes
    }
    return /** @type {any} */ (changes)
  }


}


const Map<String, dynamic> keys = <String, dynamic>{};

const dynamic target = this.target;

const dynamic changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));

const dynamic item = /** @type {Item} */ (target._map.get(key));

dynamic action;

dynamic oldValue;

dynamic prev = item.left;

dynamic changes = this._changes;

const dynamic target = this.target;

const dynamic added = set.create();

const dynamic deleted = set.create();

const List<dynamic> delta = <dynamic>[];

const dynamic changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));

dynamic lastOp = null;

const dynamic packOp = () => {;

const dynamic getPathTo = (parent, child) => {;

const List<dynamic> path = <dynamic>[];

int i = 0;

dynamic c = /** @type {AbstractType<any>} */ (child._item.parent)._start;

