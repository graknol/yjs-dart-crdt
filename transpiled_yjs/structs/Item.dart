// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions





import 'polyfill.dart';

dynamic nextID = id;

int diff = 0;

dynamic item;

const dynamic  = null;

const dynamic rightItem = Item(;

const dynamic rightItem = leftStruct.splice(diff);

const dynamic isDeletedByUndoStack = (stack, id) => array.some(stack, /** @param {StackItem} s */ s => s.deletions.hasId(id));

const dynamic doc = transaction.doc;

const dynamic store = doc.store;

const dynamic ownClientID = doc.clientID;

const dynamic redone = item.redone;

dynamic parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;

dynamic left = null;

dynamic right;

const dynamic parentType = parentItem === null ? /** @type {AbstractType<any>} */ (item.parent) : /** @type {ContentType} */ (parentItem.content).type;

dynamic leftTrace = left;

dynamic rightTrace = right;

const dynamic nextClock = getState(store, ownClientID);

const dynamic nextId = createID(ownClientID, nextClock);

const dynamic redoneItem = Item(;

class Item extends AbstractStruct {
  constructor(String id, dynamic left, dynamic origin, dynamic right, dynamic rightOrigin, dynamic parent, dynamic parentSub, dynamic content)   constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id, content.getLength())
    /**
     * The item that was originally to the left of this item.
     * @type {ID | null}
     */
    this.origin = origin
    /**
     * The item that is currently to the left of this item.
     * @type {Item | null}
     */
    this.left = left
    /**
     * The item that is currently to the right of this item.
     * @type {Item | null}
     */
    this.right = right
    /**
     * The item that was originally to the right of this item.
     * @type {ID | null}
     */
    this.rightOrigin = rightOrigin
    /**
     * @type {AbstractType<any>|ID|null}
     */
    this.parent = parent
    /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     * @type {String | null}
     */
    this.parentSub = parentSub
    /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     * @type {ID | null}
     */
    this.redone = null
    /**
     * @type {AbstractContent}
     */
    this.content = content
    /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     * @type {number} byte
     */
    this.info = this.content.isCountable() ? binary.BIT2 : 0
  }


  void marker(dynamic isMarked)   set marker (isMarked) {
    if (((this.info & binary.BIT4) > 0) != isMarked) {
      this.info ^= binary.BIT4
    }
  }


  dynamic marker()   get marker () {
    return (this.info & binary.BIT4) > 0
  }


  dynamic keep()   get keep () {
    return (this.info & binary.BIT1) > 0
  }


  void keep(dynamic doKeep)   set keep (doKeep) {
    if (this.keep != doKeep) {
      this.info ^= binary.BIT1
    }
  }


  dynamic countable()   get countable () {
    return (this.info & binary.BIT2) > 0
  }


  dynamic deleted()   get deleted () {
    return (this.info & binary.BIT3) > 0
  }


  void deleted(dynamic doDelete)   set deleted (doDelete) {
    if (this.deleted != doDelete) {
      this.info ^= binary.BIT3
    }
  }


  void markDeleted()   markDeleted () {
    this.info |= binary.BIT3
  }


  void getMissing(dynamic transaction, dynamic store)   getMissing (transaction, store) {
    if (this.origin && (this.origin.clock >= getState(store, this.origin.client) || store.skips.hasId(this.origin))) {
      return this.origin.client
    }
    if (this.rightOrigin && (this.rightOrigin.clock >= getState(store, this.rightOrigin.client) || store.skips.hasId(this.rightOrigin))) {
      return this.rightOrigin.client
    }
    if (this.parent && this.parent.constructor == ID && (this.parent.clock >= getState(store, this.parent.client) || store.skips.hasId(this.parent))) {
      return this.parent.client
    }
    // We have all missing ids, now find the items
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin)
      this.origin = this.left.lastId
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin)
      this.rightOrigin = this.right.id
    }
    if ((this.left && this.left.constructor == GC) || (this.right && this.right.constructor == GC)) {
      this.parent = null
    } else if (!this.parent) {
      // only set parent if this shouldn't be garbage collected
      if (this.left && this.left.constructor == Item) {
        this.parent = this.left.parent
        this.parentSub = this.left.parentSub
      } else if (this.right && this.right.constructor == Item) {
        this.parent = this.right.parent
        this.parentSub = this.right.parentSub
      }
    } else if (this.parent.constructor == ID) {
      const parentItem = getItem(store, this.parent)
      if (parentItem.constructor == GC) {
        this.parent = null
      } else {
        this.parent = /** @type {ContentType} */ (parentItem.content).type
      }
    }
    return null
  }


  void integrate(dynamic transaction, int offset)   integrate (transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1))
      this.origin = this.left.lastId
      this.content = this.content.splice(offset)
      this.length -= offset
    }

    if (this.parent) {
      if ((!this.left && (!this.right || this.right.left != null)) || (this.left && this.left.right != this.right)) {
        /**
         * @type {Item|null}
         */
        let left = this.left

        /**
         * @type {Item|null}
         */
        let o
        // set o to the first conflicting item
        if (left != null) {
          o = left.right
        } else if (this.parentSub != null) {
          o = /** @type {AbstractType<any>} */ (this.parent)._map[this.parentSub] || null
          while (o != null && o.left != null) {
            o = o.left
          }
        } else {
          o = /** @type {AbstractType<any>} */ (this.parent)._start
        }
        // TODO: use something like DeleteSet here (a tree implementation would be best)
        // @todo use global set definitions
        /**
         * @type {Set<Item>}
         */
        const conflictingItems = <dynamic>{}
        /**
         * @type {Set<Item>}
         */
        const itemsBeforeOrigin = <dynamic>{}
        // Let c in conflictingItems, b in itemsBeforeOrigin
        // ***{origin}bbbb{this}{c,b}{c,b}{o}***
        // Note that conflictingItems is a subset of itemsBeforeOrigin
        while (o != null && o != this.right) {
          itemsBeforeOrigin.add(o)
          conflictingItems.add(o)
          if (compareIDs(this.origin, o.origin)) {
            // case 1
            if (o.id.client < this.id.client) {
              left = o
              conflictingItems.clear()
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              // this and o are conflicting and point to the same integration points. The id decides which item comes first.
              // Since this is to the left of o, we can break here
              break
            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
          } else if (o.origin != null && itemsBeforeOrigin.containsKey(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.
            // case 2
            if (!conflictingItems.containsKey(getItem(transaction.doc.store, o.origin))) {
              left = o
              conflictingItems.clear()
            }
          } else {
            break
          }
          o = o.right
        }
        this.left = left
      }
      // reconnect left/right + update parent map/start if necessary
      if (this.left != null) {
        const right = this.left.right
        this.right = right
        this.left.right = this
      } else {
        let r
        if (this.parentSub != null) {
          r = /** @type {AbstractType<any>} */ (this.parent)._map[this.parentSub] || null
          while (r != null && r.left != null) {
            r = r.left
          }
        } else {
          r = /** @type {AbstractType<any>} */ (this.parent)._start
          ;/** @type {AbstractType<any>} */ (this.parent)._start = this
        }
        this.right = r
      }
      if (this.right != null) {
        this.right.left = this
      } else if (this.parentSub != null) {
        // set as current parent value if right == null and this is parentSub
        /** @type {AbstractType<any>} */ (this.parent)._map[this.parentSub] = this
        if (this.left != null) {
          // this is the current attribute value of parent. delete right
          this.left.remove(transaction)
        }
      }
      // adjust length of parent
      if (this.parentSub == null && this.countable && !this.deleted) {
        /** @type {AbstractType<any>} */ (this.parent)._length += this.length
      }
      addStructToIdSet(transaction.insertSet, this)
      addStruct(transaction.doc.store, this)
      this.content.integrate(transaction, this)
      // add parent to transaction.changed
      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub)
      if ((/** @type {AbstractType<any>} */ (this.parent)._item != null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub != null && this.right != null)) {
        // delete if parent is deleted or if this is not the current attribute value of parent
        this.remove(transaction)
      }
    } else {
      // parent is not defined. Integrate GC struct instead
      new GC(this.id, this.length).integrate(transaction, 0)
    }
  }


  dynamic next()   get next () {
    let n = this.right
    while (n != null && n.deleted) {
      n = n.right
    }
    return n
  }


  dynamic prev()   get prev () {
    let n = this.left
    while (n != null && n.deleted) {
      n = n.left
    }
    return n
  }


  dynamic lastId()   get lastId () {
    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
    return this.length == 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)
  }


  bool mergeWith(dynamic right)   mergeWith (right) {
    if (
      this.constructor == right.constructor &&
      compareIDs(right.origin, this.lastId) &&
      this.right == right &&
      compareIDs(this.rightOrigin, right.rightOrigin) &&
      this.id.client == right.id.client &&
      this.id.clock + this.length == right.id.clock &&
      this.deleted == right.deleted &&
      this.redone == null &&
      right.redone == null &&
      this.content.constructor == right.content.constructor &&
      this.content.mergeWith(right.content)
    ) {
      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker
      if (searchMarker) {
        searchMarker.forEach(marker => {
          if (marker.p == right) {
            // right is going to be "forgotten" so we need to update the marker
            marker.p = this
            // adjust marker index
            if (!this.deleted && this.countable) {
              marker.index -= this.length
            }
          }
        })
      }
      if (right.keep) {
        this.keep = true
      }
      this.right = right.right
      if (this.right != null) {
        this.right.left = this
      }
      this.length += right.length
      return true
    }
    return false
  }


  void delete(dynamic transaction)   delete (transaction) {
    if (!this.deleted) {
      const parent = /** @type {AbstractType<any>} */ (this.parent)
      // adjust the length of parent
      if (this.countable && this.parentSub == null) {
        parent._length -= this.length
      }
      this.markDeleted()
      addToIdSet(transaction.deleteSet, this.id.client, this.id.clock, this.length)
      addChangedTypeToTransaction(transaction, parent, this.parentSub)
      this.content.remove(transaction)
    }
  }


  void gc(dynamic tr, dynamic parentGCd)   gc (tr, parentGCd) {
    if (!this.deleted) {
      throw error.unexpectedCase()
    }
    this.content.gc(tr)
    if (parentGCd) {
      replaceStruct(tr, this, new GC(this.id, this.length))
    } else {
      this.content = new ContentDeleted(this.length)
    }
  }


  void write(dynamic encoder, int offset, int offsetEnd)   write (encoder, offset, offsetEnd) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin
    const rightOrigin = this.rightOrigin
    const parentSub = this.parentSub
    const info = (this.content.getRef() & binary.BITS5) |
      (origin == null ? 0 : binary.BIT8) | // origin is defined
      (rightOrigin == null ? 0 : binary.BIT7) | // right origin is defined
      (parentSub == null ? 0 : binary.BIT6) // parentSub is non-null
    encoder.writeInfo(info)
    if (origin != null) {
      encoder.writeLeftID(origin)
    }
    if (rightOrigin != null) {
      encoder.writeRightID(rightOrigin)
    }
    if (origin == null && rightOrigin == null) {
      const parent = /** @type {AbstractType<any>} */ (this.parent)
      if (parent._item != undefined) {
        const parentItem = parent._item
        if (parentItem == null) {
          // parent type on y._map
          // find the correct key
          const ykey = findRootTypeKey(parent)
          encoder.writeParentInfo(true) // write parentYKey
          encoder.writeString(ykey)
        } else {
          encoder.writeParentInfo(false) // write parent id
          encoder.writeLeftID(parentItem.id)
        }
      } else if (parent.constructor == String) { // this edge case was added by differential updates
        encoder.writeParentInfo(true) // write parentYKey
        encoder.writeString(parent)
      } else if (parent.constructor == ID) {
        encoder.writeParentInfo(false) // write parent id
        encoder.writeLeftID(parent)
      } else {
        error.unexpectedCase()
      }
      if (parentSub != null) {
        encoder.writeString(parentSub)
      }
    }
    this.content.write(encoder, offset, offsetEnd)
  }


}


const dynamic parentItem = getItem(store, this.parent);

dynamic left = this.left;

dynamic o;

const Map<String, dynamic> conflictingItems = <dynamic>{};

const Map<String, dynamic> itemsBeforeOrigin = <dynamic>{};

const dynamic right = this.left.right;

dynamic r;

dynamic n = this.right;

dynamic n = this.left;

const dynamic searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker;

const dynamic parent = /** @type {AbstractType<any>} */ (this.parent);

const dynamic origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;

const dynamic rightOrigin = this.rightOrigin;

const dynamic parentSub = this.parentSub;

const dynamic info = (this.content.getRef() & binary.BITS5) |;

const dynamic parent = /** @type {AbstractType<any>} */ (this.parent);

const dynamic parentItem = parent._item;

const dynamic ykey = findRootTypeKey(parent);

class AbstractContent {
  void getLength()   getLength () {
    throw error.methodUnimplemented()
  }


  void getContent()   getContent () {
    throw error.methodUnimplemented()
  }


  void isCountable()   isCountable () {
    throw error.methodUnimplemented()
  }


  void copy()   copy () {
    throw error.methodUnimplemented()
  }


  void splice(int _offset)   splice (_offset) {
    throw error.methodUnimplemented()
  }


  void mergeWith(dynamic _right)   mergeWith (_right) {
    throw error.methodUnimplemented()
  }


  void integrate(dynamic _transaction, dynamic _item)   integrate (_transaction, _item) {
    throw error.methodUnimplemented()
  }


  void delete(dynamic _transaction)   delete (_transaction) {
    throw error.methodUnimplemented()
  }


  void gc(dynamic _transaction)   gc (_transaction) {
    throw error.methodUnimplemented()
  }


  void write(dynamic _encoder, int _offset, int _offsetEnd)   write (_encoder, _offset, _offsetEnd) {
    throw error.methodUnimplemented()
  }


  void getRef()   getRef () {
    throw error.methodUnimplemented()
  }


}


