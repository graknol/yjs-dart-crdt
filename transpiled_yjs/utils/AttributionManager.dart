// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions






import 'polyfill.dart';

const Map<String, dynamic> attribution = <String, dynamic>{};

const dynamic as = /** @type {import('../utils/Delta.js').Attribution_} */ (attribution);

const dynamic ls = as[attr.name] = as[attr.name] ?? [];

class AttributedContent {
  void import(String './IdMap.js')    * @param {Array<import('./IdMap.js').AttributionItem<T>> | null} attrs


  constructor(dynamic content, dynamic clock, dynamic deleted, dynamic attrs, dynamic renderBehavior)   constructor (content, clock, deleted, attrs, renderBehavior) {
    this.content = content
    this.clock = clock
    this.deleted = deleted
    this.attrs = attrs
    this.render = renderBehavior == 0 ? false : (renderBehavior == 1 ? (!deleted || attrs != null) : true)
  }


}


class AbstractAttributionManager extends ObservableV2 {
  void operation(dynamic if unattributed and deleted, dynamic render as delete)    * @param {0|1|2} _shouldRender - 0: if undeleted or attributed, render as a retain operation. 1: render only if undeleted or attributed. 2: render as insert operation (if unattributed and deleted, render as delete).


  void readContent(dynamic _contents, dynamic _client, dynamic _clock, dynamic _deleted, dynamic _content, dynamic _shouldRender)   readContent (_contents, _client, _clock, _deleted, _content, _shouldRender) {
    error.methodUnimplemented()
  }


  void contentLength(dynamic _item)   contentLength (_item) {
    error.methodUnimplemented()
  }


}


class TwosetAttributionManager extends ObservableV2 {
  constructor(dynamic inserts, dynamic deletes)   constructor (inserts, deletes) {
    super()
    this.inserts = inserts
    this.deletes = deletes
  }


  void readContent(dynamic contents, dynamic client, dynamic clock, dynamic deleted, dynamic content, dynamic shouldRender)   readContent (contents, client, clock, deleted, content, shouldRender) {
    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, content.getLength())
    content = slice.length == 1 ? content : content.copy()
    slice.forEach(s => {
      const c = content
      if (s.len < c.getLength()) {
        content = c.splice(s.len)
      }
      if (!deleted || s.attrs != null || shouldRender) {
        contents.add(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender))
      }
    })
  }


  dynamic contentLength(dynamic item)   contentLength (item) {
    if (!item.content.isCountable()) {
      return 0
    } else if (!item.deleted) {
      return item.length
    } else {
      return this.deletes.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)
    }
  }


}


const dynamic slice = (deleted ? this.deletes : this.inserts).slice(client, clock, content.getLength());

const dynamic c = content;

class NoAttributionsManager extends ObservableV2 {
  void readContent(dynamic contents, dynamic _client, dynamic clock, dynamic deleted, dynamic content, dynamic shouldRender)   readContent (contents, _client, clock, deleted, content, shouldRender) {
    if (!deleted || shouldRender) {
      contents.add(new AttributedContent(content, clock, deleted, null, shouldRender))
    }
  }


  dynamic contentLength(dynamic item)   contentLength (item) {
    return (item.deleted || !item.content.isCountable()) ? 0 : item.length
  }


}


const dynamic getItemContent = (store, client, clock, len) => {;

const dynamic prevItem = getItem(store, createID(client, clock));

const dynamic diffStart = clock - prevItem.id.clock;

dynamic content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content;

const dynamic collectSuggestedChanges = (tr, am, start, end, collectAll) => {;

const dynamic inserts = createIdSet();

const dynamic deletes = createIdSet();

const dynamic store = am._nextDoc.store;

const Map<String, dynamic> openedCollectedFormats = <dynamic>{};

dynamic item = getItem(store, start);

const dynamic endItem = start === end ? item : (end == null ? null : getItem(store, end));

const dynamic slice = am.inserts.slice(item.id.client, item.id.clock, item.length);

const dynamic s = slice[i];

bool foundEndItem = false;

const dynamic itemClient = item.id.client;

const dynamic slice = (item.deleted ? am.deletes : am.inserts).slice(itemClient, item.id.clock, item.length);

const dynamic s = slice[i];

const dynamic splicedItem = getItemCleanStart(tr, createID(itemClient, s.clock));

const dynamic  = null;

const dynamic s = slice[i];

class DiffAttributionManager extends ObservableV2 {
  constructor(dynamic prevDoc, dynamic nextDoc)   constructor (prevDoc, nextDoc) {
    super()
    const _nextDocInserts = createInsertSetFromStructStore(nextDoc.store, false) // unmaintained
    const _prevDocInserts = createInsertSetFromStructStore(prevDoc.store, false) // unmaintained
    const nextDocDeletes = createDeleteSetFromStructStore(nextDoc.store) // maintained
    const prevDocDeletes = createDeleteSetFromStructStore(prevDoc.store) // maintained
    this.inserts = createIdMapFromIdSet(diffIdSet(_nextDocInserts, _prevDocInserts), [])
    this.deletes = createIdMapFromIdSet(diffIdSet(nextDocDeletes, prevDocDeletes), [])
    this._prevDoc = prevDoc
    this._prevDocStore = prevDoc.store
    this._nextDoc = nextDoc
    // update before observer calls fired
    this._nextBOH = nextDoc.on('beforeObserverCalls', tr => {
      // update inserts
      const diffInserts = diffIdSet(tr.insertSet, _prevDocInserts)
      insertIntoIdMap(this.inserts, createIdMapFromIdSet(diffInserts, []))
      // update deletes
      const diffDeletes = diffIdSet(diffIdSet(tr.deleteSet, prevDocDeletes), this.inserts)
      insertIntoIdMap(this.deletes, createIdMapFromIdSet(diffDeletes, []))
      // @todo fire update ranges on `diffInserts` and `diffDeletes`
    })
    this._prevBOH = prevDoc.on('beforeObserverCalls', tr => {
      insertIntoIdSet(_prevDocInserts, tr.insertSet)
      insertIntoIdSet(prevDocDeletes, tr.deleteSet)
      // insertIntoIdMap(this.inserts, createIdMapFromIdSet(intersectSets(tr.insertSet, this.inserts), [createAttributionItem('acceptInsert', 'unknown')]))
      if (tr.insertSet.clients.size < 2) {
        tr.insertSet.forEach((attrRange, client) => {
          this.inserts.remove(client, attrRange.clock, attrRange.len)
        })
      } else {
        this.inserts = diffIdMap(this.inserts, tr.insertSet)
      }
      // insertIntoIdMap(this.deletes, createIdMapFromIdSet(intersectSets(tr.deleteSet, this.deletes), [createAttributionItem('acceptDelete', 'unknown')]))
      if (tr.deleteSet.clients.size < 2) {
        tr.deleteSet.forEach((attrRange, client) => {
          this.deletes.remove(client, attrRange.clock, attrRange.len)
        })
      } else {
        this.deletes = diffIdMap(this.deletes, tr.deleteSet)
      }
      // fire event of "changed" attributions. exclude items that were added & deleted in the same
      // transaction
      this.emit('change', [diffIdSet(mergeIdSets([tr.insertSet, tr.deleteSet]), intersectSets(tr.insertSet, tr.deleteSet)), tr.origin, tr.local])
    })
    // changes from prevDoc should always flow into suggestionDoc
    // changes from suggestionDoc only flow into ydoc if suggestion-mode is disabled
    this._prevUpdateListener = prevDoc.on('update', (update, origin) => {
      origin != this && applyUpdate(nextDoc, update)
    })
    this._ndUpdateListener = nextDoc.on('update', (update, origin, _doc, tr) => {
      // only if event is local and suggestion mode is enabled
      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o == origin))) {
        applyUpdate(prevDoc, update, this)
      }
    })
    this._afterTrListener = nextDoc.on('afterTransaction', (tr) => {
      // apply deletes on attributed deletes (content that is already deleted, but is rendered by
      // the attribution manager)
      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o == tr.origin))) {
        const attributedDeletes = tr.meta['attributedDeletes']
        if (attributedDeletes != null) {
          transact(prevDoc, () => {
            // apply attributed deletes if there are any
            const ds = new UpdateEncoderV1()
            encoding.writeVarUint(ds.restEncoder, 0) // encode 0 structs
            writeIdSet(ds, attributedDeletes)
            applyUpdate(prevDoc, ds.toUint8Array())
          }, this)
        }
      }
    })
    this.suggestionMode = true
    /**
     * Optionally limit origins that may sync changes to the main doc if suggestion-mode is
     * disabled.
     *
     * @type {Array<any>?}
     */
    this.suggestionOrigins = null
    this._destroyHandler = nextDoc.on('destroy', this.destroy.bind(this))
    prevDoc.on('destroy', this._destroyHandler)
  }


  void destroy()   destroy () {
    super.destroy()
    this._nextDoc.off('destroy', this._destroyHandler)
    this._prevDoc.off('destroy', this._destroyHandler)
    this._nextDoc.off('beforeObserverCalls', this._nextBOH)
    this._prevDoc.off('beforeObserverCalls', this._prevBOH)
    this._prevDoc.off('update', this._prevUpdateListener)
    this._nextDoc.off('update', this._ndUpdateListener)
    this._nextDoc.off('afterTransaction', this._afterTrListener)
  }


  void acceptChanges(dynamic start, dynamic end = start)   acceptChanges (start, end = start) {
    const { inserts, deletes } = collectSuggestedChanges(null, this, start, end, true)
    const encoder = new UpdateEncoderV1()
    writeStructsFromIdSet(encoder, this._nextDoc.store, inserts)
    writeIdSet(encoder, deletes)
    applyUpdate(this._prevDoc, encoder.toUint8Array())
  }


  void rejectChanges(dynamic start, dynamic end = start)   rejectChanges (start, end = start) {
    this._nextDoc.transact(tr => {
      const { inserts, deletes } = collectSuggestedChanges(tr, this, start, end, false)
      const encoder = new UpdateEncoderV1()
      writeStructsFromIdSet(encoder, this._nextDoc.store, inserts)
      writeIdSet(encoder, deletes)
      const um = new UndoManager(this._nextDoc)
      um.undoStack.add(new StackItem(deletes, inserts))
      um.undo()
      um.destroy()
    })
    this.acceptChanges(start, end)
  }


  void readContent(dynamic contents, dynamic client, dynamic clock, dynamic deleted, dynamic _content, dynamic shouldRender)   readContent (contents, client, clock, deleted, _content, shouldRender) {
    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, _content.getLength())
    /**
     * @type {AbstractContent?}
     */
    let content = slice.length == 1 ? _content : _content.copy()
    for (let i = 0; i < slice.length; i++) {
      const s = slice[i]
      if (content == null || content instanceof ContentDeleted) {
        if ((!shouldRender && s.attrs == null) || this.inserts.containsKey(client, s.clock)) {
          continue
        }
        // Retrieved item is never more fragmented than the newer item.
        const prevItem = getItem(this._prevDocStore, createID(client, s.clock))
        const diffStart = s.clock - prevItem.id.clock
        content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content
        // trim itemContent to the correct size.
        if (diffStart > 0) {
          content = content.splice(diffStart)
        }
      }
      const c = /** @type {AbstractContent} */ (content)
      const clen = c.getLength()
      if (clen < s.len) {
        slice.splice(i + 1, 0, createMaybeAttrRange(s.clock + clen, s.len - clen, s.attrs))
        s.len = clen
      }
      content = s.len < clen ? c.splice(s.len) : null
      if (shouldRender || !deleted || s.attrs != null) {
        contents.add(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender))
      }
    }
  }


  dynamic contentLength(dynamic item)   contentLength (item) {
    if (!item.deleted) {
      return item.content.isCountable() ? item.length : 0
    }
    /**
     * @type {Array<AttributedContent<any>>}
     */
    const cs = []
    this.readContent(cs, item.id.client, item.id.clock, true, item.content, 0)
    return cs.reduce((cnt, c) => cnt + ((c.attrs != null && c.content.isCountable()) ? c.content.getLength() : 0), 0)
  }


}


const dynamic attributedDeletes = tr.meta.get('attributedDeletes');

const dynamic ds = UpdateEncoderV1();

const dynamic  = null;

const dynamic encoder = UpdateEncoderV1();

const dynamic  = null;

const dynamic encoder = UpdateEncoderV1();

const dynamic um = UndoManager(this._nextDoc);

const dynamic slice = (deleted ? this.deletes : this.inserts).slice(client, clock, _content.getLength());

dynamic content = slice.length === 1 ? _content : _content.copy();

const dynamic s = slice[i];

const dynamic prevItem = getItem(this._prevDocStore, createID(client, s.clock));

const dynamic diffStart = s.clock - prevItem.id.clock;

const dynamic c = /** @type {AbstractContent} */ (content);

const dynamic clen = c.getLength();

const List<dynamic> cs = <dynamic>[];

class SnapshotAttributionManager extends ObservableV2 {
  constructor(dynamic prevSnapshot, dynamic nextSnapshot)   constructor (prevSnapshot, nextSnapshot) {
    super()
    this.prevSnapshot = prevSnapshot
    this.nextSnapshot = nextSnapshot
    const inserts = createIdMap()
    const deletes = createIdMapFromIdSet(diffIdSet(nextSnapshot.ds, prevSnapshot.ds), [createAttributionItem('change', '')])
    nextSnapshot.sv.forEach((clock, client) => {
      const prevClock = prevSnapshot.sv[client] || 0
      inserts.add(client, 0, prevClock, []) // content is included in prevSnapshot is rendered without attributes
      inserts.add(client, prevClock, clock - prevClock, [createAttributionItem('change', '')]) // content is rendered as "inserted"
    })
    this.attrs = mergeIdMaps([diffIdMap(inserts, prevSnapshot.ds), deletes])
  }


  dynamic readContent(dynamic contents, dynamic client, dynamic clock, dynamic _deleted, dynamic content, dynamic shouldRender)   readContent (contents, client, clock, _deleted, content, shouldRender) {
    if ((this.nextSnapshot.sv[client] ?? 0) <= clock) return // future item that should not be displayed
    const slice = this.attrs.slice(client, clock, content.getLength())
    content = slice.length == 1 ? content : content.copy()
    slice.forEach(s => {
      const deleted = this.nextSnapshot.ds.containsKey(client, s.clock)
      const nonExistend = (this.nextSnapshot.sv[client] ?? 0) <= s.clock
      const c = content
      if (s.len < c.getLength()) {
        content = c.splice(s.len)
      }
      if (nonExistend) return
      if (shouldRender || !deleted || (s.attrs != null && s.attrs.length > 0)) {
        let attrsWithoutChange = s.attrs?.filter(attr => attr.name != 'change') ?? null
        if (s.attrs?.length == 0) {
          attrsWithoutChange = null
        }
        contents.add(new AttributedContent(c, s.clock, deleted, attrsWithoutChange, shouldRender))
      }
    })
  }


  dynamic contentLength(dynamic item)   contentLength (item) {
    return item.content.isCountable()
      ? (item.deleted
          ? this.attrs.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)
          : item.length
        )
      : 0
  }


}


const dynamic slice = this.attrs.slice(client, clock, content.getLength());

const dynamic deleted = this.nextSnapshot.ds.has(client, s.clock);

const dynamic nonExistend = (this.nextSnapshot.sv.get(client) ?? 0) <= s.clock;

const dynamic c = content;

dynamic attrsWithoutChange = s.attrs?.filter(attr => attr.name !== 'change') ?? null;

