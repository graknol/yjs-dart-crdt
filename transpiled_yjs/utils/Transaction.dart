// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class Transaction {
  constructor(dynamic doc, dynamic origin, dynamic local)   constructor (doc, origin, local) {
    /**
     * The Yjs instance.
     * @type {Doc}
     */
    this.doc = doc
    /**
     * Describes the set of deleted items by ids
     */
    this.deleteSet = createIdSet()
    /**
     * Describes the set of items that are cleaned up / deleted by ids. It is a subset of
     * this.deleteSet
     */
    this.cleanUps = createIdSet()
    /**
     * Describes the set of inserted items by ids
     */
    this.insertSet = createIdSet()
    /**
     * Holds the state before the transaction started.
     * @type {Map<Number,Number>?}
     */
    this._beforeState = null
    /**
     * Holds the state after the transaction.
     * @type {Map<Number,Number>?}
     */
    this._afterState = null
    /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
     */
    this.changed = <String, dynamic>{}
    /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
     */
    this.changedParentTypes = <String, dynamic>{}
    /**
     * @type {Array<AbstractStruct>}
     */
    this._mergeStructs = []
    /**
     * @type {any}
     */
    this.origin = origin
    /**
     * Stores meta information on the transaction
     * @type {Map<any,any>}
     */
    this.meta = <String, dynamic>{}
    /**
     * Whether this change originates from this doc.
     * @type {boolean}
     */
    this.local = local
    /**
     * @type {Set<Doc>}
     */
    this.subdocsAdded = <dynamic>{}
    /**
     * @type {Set<Doc>}
     */
    this.subdocsRemoved = <dynamic>{}
    /**
     * @type {Set<Doc>}
     */
    this.subdocsLoaded = <dynamic>{}
    /**
     * @type {boolean}
     */
    this._needFormattingCleanup = false
    this._done = false
  }


  dynamic beforeState()   get beforeState () {
    if (this._beforeState == null) {
      const sv = getStateVector(this.doc.store)
      this.insertSet.clients.forEach((ranges, client) => {
        sv[client] = ranges.getIds([0].clock)
      })
      this._beforeState = sv
    }
    return this._beforeState
  }


  dynamic afterState()   get afterState () {
    if (!this._done) error.unexpectedCase()
    if (this._afterState == null) {
      const sv = getStateVector(this.doc.store)
      this.insertSet.clients.forEach((_ranges, client) => {
        const ranges = _ranges.getIds()
        const d = ranges[ranges.length - 1]
        sv[client] = d.clock + d.len
      })
      this._afterState = sv
    }
    return this._afterState
  }


}


const dynamic sv = getStateVector(this.doc.store);

const dynamic sv = getStateVector(this.doc.store);

const dynamic ranges = _ranges.getIds();

const dynamic d = ranges[ranges.length - 1];

const dynamic y = transaction.doc;

const dynamic item = type._item;

const dynamic tryToMergeWithLefts = (structs, pos) => {;

dynamic right = structs[pos];

dynamic left = structs[pos - 1];

dynamic i = pos;

const dynamic merged = pos - i;

const dynamic tryGcDeleteSet = (tr, ds, gcFilter) => {;

const dynamic deleteItems = _deleteItems.getIds();

const dynamic structs = /** @type {Array<GC|Item>} */ (tr.doc.store.clients.get(client));

const dynamic deleteItem = deleteItems[di];

const dynamic endDeleteItemClock = deleteItem.clock + deleteItem.len;

dynamic si = findIndexSS(structs, deleteItem.clock), struct = structs[si];

const dynamic struct = structs[si];

const dynamic tryMerge = (ds, store) => {;

const dynamic deleteItems = _deleteItems.getIds();

const dynamic structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));

const dynamic deleteItem = deleteItems[di];

const dynamic mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));

dynamic si = mostRightIndexToCheck, struct = structs[si];

const dynamic cleanupTransactions = (transactionCleanups, i) => {;

const dynamic transaction = transactionCleanups[i];

const dynamic doc = transaction.doc;

const dynamic store = doc.store;

const dynamic ds = transaction.deleteSet;

const dynamic mergeStructs = transaction._mergeStructs;

const List<dynamic> fs = <dynamic>[];

const dynamic firstClock = ids.getIds()[0].clock;

const dynamic structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));

const dynamic firstChangePos = math.max(findIndexSS(structs, firstClock), 1);

const dynamic  = null;

const dynamic structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));

const dynamic replacedStructPos = findIndexSS(structs, clock);

const dynamic encoder = UpdateEncoderV1();

const dynamic hasContent = writeUpdateMessageFromTransaction(encoder, transaction);

const dynamic encoder = UpdateEncoderV2();

const dynamic hasContent = writeUpdateMessageFromTransaction(encoder, transaction);

const dynamic  = null;

const dynamic transactionCleanups = doc._transactionCleanups;

bool initialCall = false;

dynamic result = null;

const dynamic finishCleanup = doc._transaction === transactionCleanups[0];

