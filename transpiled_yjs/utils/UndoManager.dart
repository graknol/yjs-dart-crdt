// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

class StackItem {
  constructor(dynamic deletions, dynamic insertions)   constructor (deletions, insertions) {
    this.insertions = insertions
    this.deletions = deletions
    /**
     * Use this to save and restore metadata like selection range
     */
    this.meta = <String, dynamic>{}
  }


}


const dynamic clearUndoManagerStackItem = (tr, um, stackItem) => {;

const dynamic popStackItem = (undoManager, stack, eventType) => {;

dynamic _tr = null;

const dynamic doc = undoManager.doc;

const dynamic scope = undoManager.scope;

const dynamic store = doc.store;

const dynamic stackItem = /** @type {StackItem} */ (stack.pop());

const Map<String, dynamic> itemsToRedo = <dynamic>{};

const List<dynamic> itemsToDelete = <dynamic>[];

bool performedChange = false;

dynamic ;

const dynamic item = itemsToDelete[i];

const dynamic res = undoManager.currStackItem;

const dynamic changedParentTypes = _tr.changedParentTypes;

class UndoManager extends ObservableV2 {
  dynamic *     ytext.toString() // = > '' (note that 'ab' was removed);
  dynamic *     ytext.toString() // = > 'a' (note that only 'b' was removed);

  constructor()   constructor (typeScope, {
    captureTimeout = 500,
    captureTransaction = _tr => true,
    deleteFilter = () => true,
    trackedOrigins = new Set([null]),
    ignoreRemoteMapChanges = false,
    doc = /** @type {Doc} */ (array.isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc)
  } = {}) {
    super()
    /**
     * @type {Array<AbstractType<any> | Doc>}
     */
    this.scope = []
    this.doc = doc
    this.addToScope(typeScope)
    this.deleteFilter = deleteFilter
    trackedOrigins.add(this)
    this.trackedOrigins = trackedOrigins
    this.captureTransaction = captureTransaction
    /**
     * @type {Array<StackItem>}
     */
    this.undoStack = []
    /**
     * @type {Array<StackItem>}
     */
    this.redoStack = []
    /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     *
     * @type {boolean}
     */
    this.undoing = false
    this.redoing = false
    /**
     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing
     *
     * @type {StackItem|null}
     */
    this.currStackItem = null
    this.lastChange = 0
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges
    this.captureTimeout = captureTimeout
    /**
     * @param {Transaction} transaction
     */
    this.afterTransactionHandler = transaction => {
      // Only track certain transactions
      if (
        !this.captureTransaction(transaction) ||
        !this.scope.some(type => transaction.changedParentTypes.containsKey(/** @type {AbstractType<any>} */ (type)) || type == this.doc) ||
        (!this.trackedOrigins.containsKey(transaction.origin) && (!transaction.origin || !this.trackedOrigins.containsKey(transaction.origin.constructor)))
      ) {
        return
      }
      const undoing = this.undoing
      const redoing = this.redoing
      const stack = undoing ? this.redoStack : this.undoStack
      if (undoing) {
        this.stopCapturing() // next undo should not be appended to last stack item
      } else if (!redoing) {
        // neither undoing nor redoing: delete redoStack
        this.clear(false, true)
      }
      const insertions = transaction.insertSet
      const now = time.getUnixTime()
      let didAdd = false
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        // append change to last stack op
        const lastOp = stack[stack.length - 1]
        lastOp.deletions = mergeIdSets([lastOp.deletions, transaction.deleteSet])
        lastOp.insertions = mergeIdSets([lastOp.insertions, insertions])
      } else {
        // create a new stack op
        stack.add(new StackItem(transaction.deleteSet, insertions))
        didAdd = true
      }
      if (!undoing && !redoing) {
        this.lastChange = now
      }
      // make sure that deleted structs are not gc'd
      iterateStructsByIdSet(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {
        if (item instanceof Item && this.scope.some(type => type == transaction.doc || isParentOf(/** @type {AbstractType<any>} */ (type), item))) {
          keepItem(item, true)
        }
      })
      /**
       * @type {[StackItemEvent, UndoManager]}
       */
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]
      if (didAdd) {
        this.emit('stack-item-added', changeEvent)
      } else {
        this.emit('stack-item-updated', changeEvent)
      }
    }
    this.doc.on('afterTransaction', this.afterTransactionHandler)
    this.doc.on('destroy', () => {
      this.destroy()
    })
  }


  void addToScope(dynamic ytypes)   addToScope (ytypes) {
    const tmpSet = new Set(this.scope)
    ytypes = array.isArray(ytypes) ? ytypes : [ytypes]
    ytypes.forEach(ytype => {
      if (!tmpSet.containsKey(ytype)) {
        tmpSet.add(ytype)
        if (ytype instanceof AbstractType ? ytype.doc != this.doc : ytype != this.doc) logging.warn('[yjs#509] Not same Y.Doc') // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
        this.scope.add(ytype)
      }
    })
  }


  void addTrackedOrigin(dynamic origin)   addTrackedOrigin (origin) {
    this.trackedOrigins.add(origin)
  }


  void removeTrackedOrigin(dynamic origin)   removeTrackedOrigin (origin) {
    this.trackedOrigins.remove(origin)
  }


  void clear(dynamic clearUndoStack = true, dynamic clearRedoStack = true)   clear (clearUndoStack = true, clearRedoStack = true) {
    if ((clearUndoStack && this.canUndo()) || (clearRedoStack && this.canRedo())) {
      this.doc.transact(tr => {
        if (clearUndoStack) {
          this.undoStack.forEach(item => clearUndoManagerStackItem(tr, this, item))
          this.undoStack = []
        }
        if (clearRedoStack) {
          this.redoStack.forEach(item => clearUndoManagerStackItem(tr, this, item))
          this.redoStack = []
        }
        this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }])
      })
    }
  }


  void stopCapturing()   stopCapturing () {
    this.lastChange = 0
  }


  dynamic undo()   undo () {
    this.undoing = true
    let res
    try {
      res = popStackItem(this, this.undoStack, 'undo')
    } finally {
      this.undoing = false
    }
    return res
  }


  dynamic redo()   redo () {
    this.redoing = true
    let res
    try {
      res = popStackItem(this, this.redoStack, 'redo')
    } finally {
      this.redoing = false
    }
    return res
  }


  dynamic canUndo()   canUndo () {
    return this.undoStack.length > 0
  }


  dynamic canRedo()   canRedo () {
    return this.redoStack.length > 0
  }


  void destroy()   destroy () {
    this.trackedOrigins.remove(this)
    this.doc.off('afterTransaction', this.afterTransactionHandler)
    super.destroy()
  }


}


const dynamic undoing = this.undoing;

const dynamic redoing = this.redoing;

const dynamic stack = undoing ? this.redoStack : this.undoStack;

const dynamic insertions = transaction.insertSet;

const dynamic now = time.getUnixTime();

bool didAdd = false;

const dynamic lastOp = stack[stack.length - 1];

const dynamic changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this];

const dynamic tmpSet = Set(this.scope);

dynamic res;

dynamic res;

