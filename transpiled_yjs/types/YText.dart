// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

import 'package:placeholders.dart.dart';

const dynamic equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b));

class ItemTextListPosition {
  constructor(dynamic left, dynamic right, int index, dynamic currentAttributes, dynamic am)   constructor (left, right, index, currentAttributes, am) {
    this.left = left
    this.right = right
    this.index = index
    this.currentAttributes = currentAttributes
    this.am = am
  }


  void forward()   forward () {
    if (this.right == null) {
      error.unexpectedCase()
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content))
        }
        break
      default:
        this.index += this.am.contentLength(this.right)
        break
    }
    this.left = this.right
    this.right = this.right.right
  }


  void formatText(dynamic transaction, dynamic parent, int length, dynamic attributes)   formatText (transaction, parent, length, attributes) {
    const doc = transaction.doc
    const ownClientId = doc.clientID
    minimizeAttributeChanges(this, attributes)
    const negatedAttributes = insertAttributes(transaction, parent, this, attributes)
    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
    // eslint-disable-next-line no-labels
    iterationLoop: while (
      this.right != null &&
      (length > 0 ||
        (
          negatedAttributes.size > 0 &&
          ((this.right.deleted && this.am.contentLength(this.right) == 0) || this.right.content.constructor == ContentFormat)
        )
      )
    ) {
      switch (this.right.content.constructor) {
        case ContentFormat: {
          if (!this.right.deleted) {
            const { key, value } = /** @type {ContentFormat} */ (this.right.content)
            const attr = attributes[key]
            if (attr != undefined) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.remove(key)
              } else {
                if (length == 0) {
                  // no need to further extend negatedAttributes
                  // eslint-disable-next-line no-labels
                  break iterationLoop
                }
                negatedAttributes[key] = value
              }
              this.right.remove(transaction)
            } else {
              this.currentAttributes[key] = value
            }
          }
          break
        }
        default: {
          const item = this.right
          const rightLen = this.am.contentLength(item)
          if (length < rightLen) {
            /**
             * @type {Array<import('../internals.js').AttributedContent<any>>}
             */
            const contents = []
            this.am.readContent(contents, item.id.client, item.id.clock, item.deleted, item.content, 0)
            let i = 0
            for (; i < contents.length && length > 0; i++) {
              const c = contents[i]
              if ((!c.deleted || c.attrs != null) && c.content.isCountable()) {
                length -= c.content.getLength()
              }
            }
            if (length < 0 || (length == 0 && i != contents.length)) {
              const c = contents[--i]
              getItemCleanStart(transaction, createID(item.id.client, c.clock + c.content.getLength() + length))
            }
          } else {
            length -= rightLen
          }
          break
        }
      }
      this.forward()
    }
    // Quill just assumes that the editor starts with a newline and that it always
    // ends with a newline. We only insert that newline when a new newline is
    // inserted - i.e when length is bigger than type.length
    if (length > 0) {
      let newlines = ''
      for (; length > 0; length--) {
        newlines += '\n'
      }
      this.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), this.left, this.left && this.left.lastId, this.right, this.right && this.right.id, parent, null, new ContentString(newlines))
      this.right.integrate(transaction, 0)
      this.forward()
    }
    insertNegatedAttributes(transaction, parent, this, negatedAttributes)
  }


}


const dynamic doc = transaction.doc;

const dynamic ownClientId = doc.clientID;

const dynamic negatedAttributes = insertAttributes(transaction, parent, this, attributes);

const dynamic  = null;

const dynamic attr = attributes[key];

const dynamic item = this.right;

const dynamic rightLen = this.am.contentLength(item);

const List<dynamic> contents = <dynamic>[];

int i = 0;

const dynamic c = contents[i];

const dynamic c = contents[--i];

String newlines = '';

const dynamic findNextPosition = (transaction, pos, count) => {;

const dynamic findPosition = (transaction, parent, index, useSearchMarker) => {;

const Map<String, dynamic> currentAttributes = <String, dynamic>{};

const dynamic marker = useSearchMarker ? findMarker(parent, index) : null;

const dynamic pos = ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes, noAttributionsManager);

const dynamic pos = ItemTextListPosition(null, parent._start, 0, currentAttributes, noAttributionsManager);

const dynamic insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {;

const dynamic doc = transaction.doc;

const dynamic ownClientId = doc.clientID;

const dynamic left = currPos.left;

const dynamic right = currPos.right;

const dynamic nextFormat = Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));

const dynamic updateCurrentAttributes = (currentAttributes, format) => {;

const dynamic  = null;

const dynamic minimizeAttributeChanges = (currPos, attributes) => {;

const dynamic insertAttributes = (transaction, parent, currPos, attributes) => {;

const dynamic doc = transaction.doc;

const dynamic ownClientId = doc.clientID;

const Map<String, dynamic> negatedAttributes = <String, dynamic>{};

const dynamic val = attributes[key];

const dynamic currentVal = currPos.currentAttributes.get(key) ?? null;

const dynamic  = null;

const dynamic insertText = (transaction, parent, currPos, text, attributes) => {;

const dynamic doc = transaction.doc;

const dynamic ownClientId = doc.clientID;

const dynamic negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);

const dynamic content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text));

dynamic ;

const dynamic cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {;

dynamic end = start;

const dynamic endFormats = map.create();

const dynamic cf = /** @type {ContentFormat} */ (end.content);

int cleanups = 0;

bool reachedCurr = false;

const dynamic content = start.content;

const dynamic  = null;

const dynamic startAttrValue = startAttributes.get(key) ?? null;

const dynamic cleanupContextlessFormattingGap = (transaction, item) => {;

const Map<String, dynamic> attrs = <dynamic>{};

const dynamic key = /** @type {ContentFormat} */ (item.content).key;

int res = 0;

dynamic start = /** @type {Item} */ (type._start);

dynamic end = type._start;

dynamic startAttributes = map.create();

const dynamic currentAttributes = map.copy(startAttributes);

const Map<String, dynamic> needFullCleanup = <dynamic>{};

const dynamic doc = transaction.doc;

const dynamic parent = /** @type {YText<any>} */ (item.parent);

const dynamic deleteText = (transaction, currPos, length) => {;

const dynamic startLength = length;

const dynamic startAttrs = map.copy(currPos.currentAttributes);

const dynamic start = currPos.right;

const dynamic item = currPos.right;

const List<dynamic> contents = <dynamic>[];

const dynamic c = contents[i];

const dynamic contentLen = math.min(c.content.getLength(), length);

const dynamic lastContent = contents.length > 0 ? contents[contents.length - 1] : null;

const dynamic nextItemClock = item.id.clock + item.length;

const dynamic nextContentClock = lastContent != null ? lastContent.clock + lastContent.content.getLength() : nextItemClock;

const dynamic parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);

class YTextEvent extends YEvent {
  constructor(String ytext, dynamic transaction, dynamic subs)   constructor (ytext, transaction, subs) {
    super(ytext, transaction)
    /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */
    this.childListChanged = false
    /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */
    this.keysChanged = <dynamic>{}
    subs.forEach((sub) => {
      if (sub == null) {
        this.childListChanged = true
      } else {
        this.keysChanged.add(sub)
      }
    })
  }


  dynamic changes()   get changes () {
    if (this._changes == null) {
      /**
       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:delta.TextDelta<TextEmbeds,undefined>}}
       */
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: <dynamic>{},
        deleted: <dynamic>{}
      }
      this._changes = changes
    }
    return /** @type {any} */ (this._changes)
  }


  dynamic import(dynamic '../utils/Delta.js')    * @return {import('../utils/Delta.js').TextDelta<TextEmbeds,undefined>} The Delta representation of this type.


  dynamic getDelta(dynamic am = noAttributionsManager)   getDelta (am = noAttributionsManager) {
    const itemsToRender = mergeIdSets([diffIdSet(this.transaction.insertSet, this.transaction.deleteSet), diffIdSet(this.transaction.deleteSet, this.transaction.insertSet)])
    return this.target.getContent(am, { itemsToRender, retainDeletes: true })
  }


  dynamic delta()   get delta () {
    return this._delta ?? (this._delta = this.getDelta())
  }


}


const dynamic changes = {;

const dynamic itemsToRender = mergeIdSets([diffIdSet(this.transaction.insertSet, this.transaction.deleteSet), diffIdSet(this.transaction.deleteSet, this.transaction.insertSet)]);

class YText extends AbstractType {
  constructor(String string)   constructor (string) {
    super()
    /**
     * Array of pending operations on this type
     * @type {Array<function():void>?}
     */
    this._pending = string != undefined ? [() => this.insert(0, string)] : []
    /**
     * @type {Array<ArraySearchMarker>|null}
     */
    this._searchMarker = []
    /**
     * Whether this YText contains formatting attributes.
     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
     */
    this._hasFormatting = false
  }


  dynamic length()   get length () {
    this.doc ?? warnPrematureAccess()
    return this._length
  }


  void _integrate(dynamic y, dynamic item)   _integrate (y, item) {
    super._integrate(y, item)
    try {
      /** @type {Array<function>} */ (this._pending).forEach(f => f())
    } catch (e) {
      print(e)
    }
    this._pending = null
  }


  dynamic _copy()   _copy () {
    return new YText()
  }


  dynamic clone()   clone () {
    /**
     * @type {YText<Embeds>}
     */
    const text = new YText()
    text.applyDelta(this.getContent())
    return text
  }


  void _callObserver(dynamic transaction, dynamic parentSubs)   _callObserver (transaction, parentSubs) {
    super._callObserver(transaction, parentSubs)
    const event = new YTextEvent(this, transaction, parentSubs)
    callTypeObservers(this, transaction, event)
    // If a remote change happened, we try to cleanup potential formatting duplicates.
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true
    }
  }


  dynamic toString()   toString () {
    this.doc ?? warnPrematureAccess()
    let str = ''
    /**
     * @type {Item|null}
     */
    let n = this._start
    while (n != null) {
      if (!n.deleted && n.countable && n.content.constructor == ContentString) {
        str += /** @type {ContentString} */ (n.content).str
      }
      n = n.right
    }
    return str
  }


  dynamic toJSON()   toJSON () {
    return this.toString()
  }


  void applyDelta(dynamic delta, dynamic am = noAttributionsManager)   applyDelta (delta, am = noAttributionsManager) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        const deltaOps = /** @type {Array<any>} */ (/** @type {delta.TextDelta<any,undefined>} */ (delta).ops instanceof Array ? /** @type {delta.TextDelta<any,undefined>} */ (delta).ops : delta)
        const currPos = new ItemTextListPosition(null, this._start, 0, <String, dynamic>{}, am)
        for (let i = 0; i < deltaOps.length; i++) {
          const op = deltaOps[i]
          if (op.insert != undefined) {
            if (op.insert.length > 0 || typeof op.insert != 'string') {
              insertText(transaction, this, currPos, op.insert, op.attributes || {})
            }
          } else if (op.retain != undefined) {
            currPos.formatText(transaction, this, op.retain, op.attributes || {})
          } else if (op.delete != undefined) {
            deleteText(transaction, currPos, op.delete)
          }
        }
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.applyDelta(delta))
    }
  }


  dynamic import(dynamic '../utils/Delta.js')    * @return {import('../utils/Delta.js').TextDelta<Embeds extends import('./AbstractType.js').AbstractType<infer SubEvent> ? SubEvent : Embeds, undefined>} The Delta representation of this type.


  dynamic getContentDeep(dynamic am = noAttributionsManager)   getContentDeep (am = noAttributionsManager) {
    return this.getContent(am).map(d =>
      d instanceof delta.InsertEmbedOp && d.insert instanceof AbstractType
        ? new delta.InsertEmbedOp(d.insert.getContent(am), d.attributes, d.attribution)
        : d
    )
  }


  void import(String '../utils/IdSet.js')    * @param {import('../utils/IdSet.js').IdSet?} [opts.itemsToRender]


  dynamic import(dynamic '../utils/Delta.js')    * @return {import('../utils/Delta.js').TextDelta<Embeds,undefined>} The Delta representation of this type.


  dynamic getContent(dynamic am = noAttributionsManager, List<dynamic> { itemsToRender = null, dynamic retainInserts = false, dynamic retainDeletes = false })   getContent (am = noAttributionsManager, { itemsToRender = null, retainInserts = false, retainDeletes = false } = {}) {
    /**
     * @type {import('../utils/Delta.js').TextDeltaBuilder<Embeds>}
     */
    const d = delta.createTextDelta()
    /**
     * @type {import('../utils/Delta.js').FormattingAttributes}
     */
    let currentAttributes = {} // saves all current attributes for insert
    let usingCurrentAttributes = false
    /**
     * @type {import('../utils/Delta.js').FormattingAttributes}
     */
    let changedAttributes = {} // saves changed attributes for retain
    let usingChangedAttributes = false
    /**
     * Logic for formatting attribute attribution
     * Everything that comes after an formatting attribute is formatted by the user that created it.
     * Two exceptions:
     * - the user resets formatting to the previously known formatting that is not attributed
     * - the user deletes a formatting attribute and hence restores the previously known formatting
     *   that is not attributed.
     * @type {import('../utils/Delta.js').FormattingAttributes}
     */
    const previousUnattributedAttributes = {} // contains previously known unattributed formatting
    /**
     * @type {import('../utils/Delta.js').FormattingAttributes}
     */
    const previousAttributes = {} // The value before changes

    /**
     * @type {Array<import('../internals.js').AttributedContent<any>>}
     */
    const cs = []
    for (let item = this._start; item != null; cs.length = 0) {
      if (itemsToRender != null) {
        for (; item != null && cs.length < 50; item = item.right) {
          const rslice = itemsToRender.slice(item.id.client, item.id.clock, item.length)
          let itemContent = rslice.length > 1 ? item.content.copy() : item.content
          for (let ir = 0; ir < rslice.length; ir++) {
            const idrange = rslice[ir]
            const content = itemContent
            if (ir != rslice.length - 1) {
              itemContent = itemContent.splice(idrange.len)
            }
            am.readContent(cs, item.id.client, idrange.clock, item.deleted, content, idrange.exists ? 2 : 0)
          }
        }
      } else {
        for (; item != null && cs.length < 50; item = item.right) {
          am.readContent(cs, item.id.client, item.id.clock, item.deleted, item.content, 1)
        }
      }
      for (let i = 0; i < cs.length; i++) {
        const c = cs[i]
        // render (attributed) content even if it was deleted
        const renderContent = c.render && (!c.deleted || c.attrs != null)
        // content that was just deleted. It is not rendered as an insertion, because it doesn't
        // have any attributes.
        const renderDelete = c.render && c.deleted
        // existing content that should be retained, only adding changed attributes
        const retainContent = !c.render && (!c.deleted || c.attrs != null)
        const attribution = (renderContent || c.content.constructor == ContentFormat) ? createAttributionFromAttributionItems(c.attrs, c.deleted) : null
        switch (c.content.constructor) {
          case ContentDeleted: {
            if (renderDelete) d.remove(c.content.getLength())
            break
          }
          case ContentType:
          case ContentEmbed:
            if (renderContent) {
              d.usedAttributes = currentAttributes
              usingCurrentAttributes = true
              if (c.deleted ? retainDeletes : retainInserts) {
                d.retain(c.content.getLength(), null, attribution ?? {})
              } else {
                d.insert(c.content.getContent()[0], null, attribution)
              }
            } else if (renderDelete) {
              d.remove(1)
            } else if (retainContent) {
              d.usedAttributes = changedAttributes
              usingChangedAttributes = true
              d.retain(1)
            }
            break
          case ContentString:
            if (renderContent) {
              d.usedAttributes = currentAttributes
              usingCurrentAttributes = true
              if (c.deleted ? retainDeletes : retainInserts) {
                d.retain(/** @type {ContentString} */ (c.content).str.length, null, attribution ?? {})
              } else {
                d.insert(/** @type {ContentString} */ (c.content).str, null, attribution)
              }
            } else if (renderDelete) {
              d.remove(c.content.getLength())
            } else if (retainContent) {
              d.usedAttributes = changedAttributes
              usingChangedAttributes = true
              d.retain(c.content.getLength())
            }
            break
          case ContentFormat: {
            const { key, value } = /** @type {ContentFormat} */ (c.content)
            const currAttrVal = currentAttributes[key] ?? null
            if (attribution != null && (c.deleted || !object.hasProperty(previousUnattributedAttributes, key))) {
              previousUnattributedAttributes[key] = c.deleted ? value : currAttrVal
            }
            // @todo write a function "updateCurrentAttributes" and "updateChangedAttributes"
            // # Update Attributes
            if (renderContent || renderDelete) {
              // create fresh references
              if (usingCurrentAttributes) {
                currentAttributes = object.assign({}, currentAttributes)
                usingCurrentAttributes = false
              }
              if (usingChangedAttributes) {
                usingChangedAttributes = false
                changedAttributes = object.assign({}, changedAttributes)
              }
            }
            if (renderContent || renderDelete) {
              if (c.deleted) {
                // content was deleted, but is possibly attributed
                if (!equalAttrs(value, currAttrVal)) { // do nothing if nothing changed
                  if (equalAttrs(currAttrVal, previousAttributes[key] ?? null) && changedAttributes[key] != undefined) {
                    delete changedAttributes[key]
                  } else {
                    changedAttributes[key] = currAttrVal
                  }
                  // current attributes doesn't change
                  previousAttributes[key] = value
                }
              } else { // !c.deleted
                // content was inserted, and is possibly attributed
                if (equalAttrs(value, currAttrVal)) {
                  // item.remove(transaction)
                } else if (equalAttrs(value, previousAttributes[key] ?? null)) {
                  delete changedAttributes[key]
                } else {
                  changedAttributes[key] = value
                }
                if (value == null) {
                  delete currentAttributes[key]
                } else {
                  currentAttributes[key] = value
                }
              }
            } else if (retainContent && !c.deleted) {
              // fresh reference to currentAttributes only
              if (usingCurrentAttributes) {
                currentAttributes = object.assign({}, currentAttributes)
                usingCurrentAttributes = false
              }
              if (usingChangedAttributes && changedAttributes[key] != undefined) {
                usingChangedAttributes = false
                changedAttributes = object.assign({}, changedAttributes)
              }
              if (value == null) {
                delete currentAttributes[key]
              } else {
                currentAttributes[key] = value
              }
              delete changedAttributes[key]
              previousAttributes[key] = value
            }
            // # Update Attributions
            if (attribution != null || object.hasProperty(previousUnattributedAttributes, key)) {
              /**
               * @type {import('../utils/AttributionManager.js').Attribution}
               */
              const formattingAttribution = object.assign({}, d.usedAttribution)
              const changedAttributedAttributes = /** @type {{ [key: string]: Array<any> }} */ (formattingAttribution.attributes = object.assign({}, formattingAttribution.attributes ?? {}))
              if (attribution == null || equalAttrs(previousUnattributedAttributes[key], currentAttributes[key] ?? null)) {
                // an unattributed formatting attribute was found or an attributed formatting
                // attribute was found that resets to the previous status
                delete changedAttributedAttributes[key]
                delete previousUnattributedAttributes[key]
              } else {
                const by = changedAttributedAttributes[key] = (changedAttributedAttributes[key]?.slice() ?? [])
                by.add(...((c.deleted ? attribution.delete : attribution.insert) ?? []))
                const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt)
                if (attributedAt) formattingAttribution.attributedAt = attributedAt
              }
              if (object.isEmpty(changedAttributedAttributes)) {
                d.useAttribution(null)
              } else if (attribution != null) {
                const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt)
                if (attributedAt != null) formattingAttribution.attributedAt = attributedAt
                d.useAttribution(formattingAttribution)
              }
            }
            break
          }
        }
      }
    }
    // @todo! fix the typings here
    return /** @type {any} */ (d.done())
  }


  void insert(int index, String text, dynamic attributes)   insert (index, text, attributes) {
    if (text.length <= 0) {
      return
    }
    const y = this.doc
    if (y != null) {
      transact(y, transaction => {
        const pos = findPosition(transaction, this, index, !attributes)
        if (!attributes) {
          attributes = {}
          // @ts-ignore
          pos.currentAttributes.forEach((v, k) => { attributes[k] = v })
        }
        insertText(transaction, this, pos, text, attributes)
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.insert(index, text, attributes))
    }
  }


  void insertEmbed(int index, dynamic embed, dynamic attributes)   insertEmbed (index, embed, attributes) {
    const y = this.doc
    if (y != null) {
      transact(y, transaction => {
        const pos = findPosition(transaction, this, index, !attributes)
        insertText(transaction, this, pos, embed, attributes || {})
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.insertEmbed(index, embed, attributes || {}))
    }
  }


  void delete(int index, int length)   delete (index, length) {
    if (length == 0) {
      return
    }
    const y = this.doc
    if (y != null) {
      transact(y, transaction => {
        deleteText(transaction, findPosition(transaction, this, index, true), length)
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.remove(index, length))
    }
  }


  void format(int index, int length, dynamic attributes)   format (index, length, attributes) {
    if (length == 0) {
      return
    }
    const y = this.doc
    if (y != null) {
      transact(y, transaction => {
        const pos = findPosition(transaction, this, index, false)
        if (pos.right == null) {
          return
        }
        pos.formatText(transaction, this, length, attributes)
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.format(index, length, attributes))
    }
  }


  void removeAttribute(String attributeName)   removeAttribute (attributeName) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        typeMapDelete(transaction, this, attributeName)
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.removeAttribute(attributeName))
    }
  }


  void setAttribute(String attributeName, dynamic attributeValue)   setAttribute (attributeName, attributeValue) {
    if (this.doc != null) {
      transact(this.doc, transaction => {
        typeMapSet(transaction, this, attributeName, attributeValue)
      })
    } else {
      /** @type {Array<function>} */ (this._pending).add(() => this.setAttribute(attributeName, attributeValue))
    }
  }


  dynamic getAttribute(String attributeName)   getAttribute (attributeName) {
    return /** @type {any} */ (typeMapGet(this, attributeName))
  }


  dynamic getAttributes()   getAttributes () {
    return typeMapGetAll(this)
  }


  void _write(dynamic encoder)   _write (encoder) {
    encoder.writeTypeRef(YTextRefID)
  }


  dynamic ()   [traits.EqualityTraitSymbol] (other) {
    return this.getContent().equals(other.getContent())
  }


}


const dynamic text = YText();

const dynamic event = YTextEvent(this, transaction, parentSubs);

String str = '';

dynamic n = this._start;

const dynamic deltaOps = /** @type {Array<any>} */ (/** @type {delta.TextDelta<any,undefined>} */ (delta).ops instanceof Array ? /** @type {delta.TextDelta<any,undefined>} */ (delta).ops : delta);

const dynamic currPos = ItemTextListPosition(null, this._start, 0, new Map(), am);

const dynamic op = deltaOps[i];

const dynamic d = delta.createTextDelta();

dynamic currentAttributes = {} // saves all current attributes for insert;

bool usingCurrentAttributes = false;

dynamic changedAttributes = {} // saves changed attributes for retain;

bool usingChangedAttributes = false;

const dynamic previousUnattributedAttributes = {} // contains previously known unattributed formatting;

const dynamic previousAttributes = {} // The value before changes;

const List<dynamic> cs = <dynamic>[];

const dynamic rslice = itemsToRender.slice(item.id.client, item.id.clock, item.length);

dynamic itemContent = rslice.length > 1 ? item.content.copy() : item.content;

const dynamic idrange = rslice[ir];

const dynamic content = itemContent;

const dynamic c = cs[i];

const dynamic renderContent = c.render && (!c.deleted || c.attrs != null);

const dynamic renderDelete = c.render && c.deleted;

const dynamic retainContent = !c.render && (!c.deleted || c.attrs != null);

const dynamic attribution = (renderContent || c.content.constructor === ContentFormat) ? createAttributionFromAttributionItems(c.attrs, c.deleted) : null;

const dynamic  = null;

const dynamic currAttrVal = currentAttributes[key] ?? null;

const dynamic formattingAttribution = object.assign({}, d.usedAttribution);

const dynamic changedAttributedAttributes = /** @type {{ [key: string]: Array<any> }} */ (formattingAttribution.attributes = object.assign({}, formattingAttribution.attributes ?? {}));

const dynamic by = changedAttributedAttributes[key] = (changedAttributedAttributes[key]?.slice() ?? []);

const dynamic attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt);

const dynamic attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt);

const dynamic y = this.doc;

const dynamic pos = findPosition(transaction, this, index, !attributes);

const dynamic y = this.doc;

const dynamic pos = findPosition(transaction, this, index, !attributes);

const dynamic y = this.doc;

const dynamic y = this.doc;

const dynamic pos = findPosition(transaction, this, index, false);

