// Generated by JavaScript-to-Dart transpiler
// Manual implementation may be required for placeholder functions







import 'polyfill.dart';

class Doc extends ObservableV2 {
  dynamic * `ydoc.get(name, Y.Array) = ;
  dynamic *   const ydoc = Y.Doc(..);
  Map<String, dynamic> *   const appState = {;

  constructor(String { guid = random.uuidv4()   constructor ({ guid = random.uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true, isSuggestionDoc = false } = {}) {
    super()
    this.gc = gc
    this.gcFilter = gcFilter
    this.clientID = generateNewClientId()
    this.guid = guid
    this.collectionid = collectionid
    this.isSuggestionDoc = isSuggestionDoc
    this.cleanupFormatting = !isSuggestionDoc
    /**
     * @type {Map<string, AbstractType<YEvent<any>>>}
     */
    this.share = <String, dynamic>{}
    this.store = new StructStore()
    /**
     * @type {Transaction | null}
     */
    this._transaction = null
    /**
     * @type {Array<Transaction>}
     */
    this._transactionCleanups = []
    /**
     * @type {Set<Doc>}
     */
    this.subdocs = <dynamic>{}
    /**
     * If this document is a subdocument - a document integrated into another document - then _item is defined.
     * @type {Item?}
     */
    this._item = null
    this.shouldLoad = shouldLoad
    this.autoLoad = autoLoad
    this.meta = meta
    /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     *
     * @type {boolean}
     */
    this.isLoaded = false
    /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */
    this.isSynced = false
    this.isDestroyed = false
    /**
     * Future that resolves once the document has been loaded from a persistence provider.
     */
    this.whenLoaded = promise.create(resolve => {
      this.on('load', () => {
        this.isLoaded = true
        resolve(this)
      })
    })
    const provideSyncedFuture = () => promise.create(resolve => {
      /**
       * @param {boolean} isSynced
       */
      const eventHandler = (isSynced) => {
        if (isSynced == undefined || isSynced == true) {
          this.off('sync', eventHandler)
          resolve()
        }
      }
      this.on('sync', eventHandler)
    })
    this.on('sync', isSynced => {
      if (isSynced == false && this.isSynced) {
        this.whenSynced = provideSyncedFuture()
      }
      this.isSynced = isSynced == undefined || isSynced == true
      if (this.isSynced && !this.isLoaded) {
        this.emit('load', [this])
      }
    })
    /**
     * Future that resolves once the document has been synced with a backend.
     * This promise is recreated when the connection is lost.
     * Note the documentation about the `isSynced` property.
     */
    this.whenSynced = provideSyncedFuture()
  }


  void load()   load () {
    const item = this._item
    if (item != null && !this.shouldLoad) {
      transact(/** @type {any} */ (item.parent).doc, transaction => {
        transaction.subdocsLoaded.add(this)
      }, null, true)
    }
    this.shouldLoad = true
  }


  dynamic getSubdocs()   getSubdocs () {
    return this.subdocs
  }


  dynamic getSubdocGuids()   getSubdocGuids () {
    return new Set(array.from(this.subdocs).map(doc => doc.guid))
  }


  void function(dynamic Transaction)    * @param {function(Transaction):T} f The function that should be executed as a transaction


  dynamic transact(dynamic f, dynamic origin = null)   transact (f, origin = null) {
    return transact(this, f, origin)
  }


  dynamic get(String name, dynamic TypeConstructor = /** @type {any} */ (AbstractType)   get (name, TypeConstructor = /** @type {any} */ (AbstractType)) {
    const type = map.setIfUndefined(this.share, name, () => {
      // @ts-ignore
      const t = new TypeConstructor()
      t._integrate(this, null)
      return t
    })
    const Constr = type.constructor
    if (TypeConstructor != AbstractType && Constr != TypeConstructor) {
      if (Constr == AbstractType) {
        // @ts-ignore
        const t = new TypeConstructor()
        t._map = type._map
        type._map.forEach(/** @param {Item?} n */ n => {
          for (; n != null; n = n.left) {
            // @ts-ignore
            n.parent = t
          }
        })
        t._start = type._start
        for (let n = t._start; n != null; n = n.right) {
          n.parent = t
        }
        t._length = type._length
        this.share[name] = t
        t._integrate(this, null)
        return /** @type {InstanceType<Type>} */ (t)
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)
      }
    }
    return /** @type {InstanceType<Type>} */ (type)
  }


  dynamic getArray(String name = '')   getArray (name = '') {
    return /** @type {YArray<T>} */ (this[name, YArray])
  }


  dynamic getText(String name = '')   getText (name = '') {
    return this[name, YText]
  }


  dynamic getMap(String name = '')   getMap (name = '') {
    return /** @type {YMap<T>} */ (this[name, YMap])
  }


  dynamic getXmlElement(String name = '')   getXmlElement (name = '') {
    return /** @type {YXmlElement<{[key:string]:string}>} */ (this[name, YXmlElement])
  }


  dynamic getXmlFragment(String name = '')   getXmlFragment (name = '') {
    return this[name, YXmlFragment]
  }


  dynamic toJSON()   toJSON () {
    /**
     * @type {Object<string, any>}
     */
    const doc = {}

    this.share.forEach((value, key) => {
      doc[key] = value.toJSON()
    })

    return doc
  }


  void destroy()   destroy () {
    this.isDestroyed = true
    array.from(this.subdocs).forEach(subdoc => subdoc.destroy())
    const item = this._item
    if (item != null) {
      this._item = null
      const content = /** @type {ContentDoc} */ (item.content)
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false })
      content.doc._item = item
      transact(/** @type {any} */ (item).parent.doc, transaction => {
        const doc = content.doc
        if (!item.deleted) {
          transaction.subdocsAdded.add(doc)
        }
        transaction.subdocsRemoved.add(this)
      }, null, true)
    }
    // @ts-ignore
    this.emit('destroyed', [true]) // DEPRECATED!
    this.emit('destroy', [this])
    super.destroy()
  }


}


const dynamic provideSyncedPromise = () => promise.create(resolve => {;

const dynamic eventHandler = (isSynced) => {;

const dynamic item = this._item;

const dynamic type = map.setIfUndefined(this.share, name, () => {;

const dynamic t = TypeConstructor();

const dynamic Constr = type.constructor;

const dynamic t = TypeConstructor();

const Map<String, dynamic> doc = <String, dynamic>{};

const dynamic item = this._item;

const dynamic content = /** @type {ContentDoc} */ (item.content);

const dynamic doc = content.doc;

const dynamic clone = Doc(opts);

